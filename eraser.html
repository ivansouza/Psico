import React, { useState, useRef, useEffect } from 'react';
import { 
  Eraser, Undo, Redo, Download, Upload, 
  Image as ImageIcon, Sparkles, Move, Gem, CheckCircle2
} from 'lucide-react';

export default function MagicEraserPattern() {
  const [image, setImage] = useState(null);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [brushSize, setBrushSize] = useState(40);
  const [isProcessing, setIsProcessing] = useState(false);
  const [mode, setMode] = useState('view');
  const [transform, setTransform] = useState({ k: 1, x: 0, y: 0 });
  const [lastAction, setLastAction] = useState(null);
  
  const imageCanvasRef = useRef(null);
  const overlayCanvasRef = useRef(null);
  const containerRef = useRef(null);
  const fileInputRef = useRef(null);
  
  const isDragging = useRef(false);
  const isPinching = useRef(false);
  const startPan = useRef({ x: 0, y: 0 });
  const startPinchDist = useRef(0);
  const startTransform = useRef({ k: 1, x: 0, y: 0 });
  
  const isDrawing = useRef(false);
  const lastDrawPos = useRef({ x: 0, y: 0 });
  const hasDrawn = useRef(false);

  // --- Sistema de Arquivos ---
  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          const maxDim = 1600; 
          let w = img.width;
          let h = img.height;
          if (w > maxDim || h > maxDim) {
            const ratio = Math.min(maxDim / w, maxDim / h);
            w *= ratio;
            h *= ratio;
          }
          const canvas = document.createElement('canvas');
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          const newImageData = ctx.getImageData(0, 0, w, h);
          
          setImage(newImageData);
          setHistory([newImageData]);
          setHistoryIndex(0);
          if (containerRef.current) {
            const containerW = containerRef.current.clientWidth;
            const containerH = containerRef.current.clientHeight;
            const scaleStart = Math.min(containerW / w, containerH / h) * 0.95;
            const xStart = (containerW - w * scaleStart) / 2;
            const yStart = (containerH - h * scaleStart) / 2;
            setTransform({ k: scaleStart, x: xStart, y: yStart });
          }
          setMode('view');
          setLastAction(null);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }
  };

  const saveImage = async () => {
    if (!imageCanvasRef.current) return;
    try {
      imageCanvasRef.current.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `magic-eraser-pattern-${Date.now()}.jpg`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 'image/jpeg', 0.98);
    } catch (err) { console.error(err); }
  };

  // --- Renderização ---
  useEffect(() => {
    if (image && imageCanvasRef.current && overlayCanvasRef.current) {
      const canvas = imageCanvasRef.current;
      const ctx = canvas.getContext('2d');
      if (canvas.width !== image.width) canvas.width = image.width;
      if (canvas.height !== image.height) canvas.height = image.height;
      ctx.putImageData(image, 0, 0);
      const overlay = overlayCanvasRef.current;
      const oCtx = overlay.getContext('2d');
      if (overlay.width !== image.width) overlay.width = image.width;
      if (overlay.height !== image.height) overlay.height = image.height;
      oCtx.clearRect(0, 0, overlay.width, overlay.height);
    }
  }, [image]);

  const containerStyle = {
    transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`,
    transformOrigin: '0 0',
    width: image ? image.width : 0,
    height: image ? image.height : 0,
  };

  const getCanvasCoordinates = (clientX, clientY) => {
    if (!containerRef.current) return { x: 0, y: 0 };
    const containerRect = containerRef.current.getBoundingClientRect();
    const x = (clientX - containerRect.left - transform.x) / transform.k;
    const y = (clientY - containerRect.top - transform.y) / transform.k;
    return { x, y };
  };

  // --- LÓGICA DE REMOÇÃO DE MARCA (Patch-Based Inpainting) ---
  const removeWatermarkPattern = async () => {
    if (!image || !imageCanvasRef.current) return;
    setIsProcessing(true);
    await new Promise(r => setTimeout(r, 50)); // Dar tempo à UI

    const w = image.width;
    const h = image.height;
    const canvas = imageCanvasRef.current;
    const ctx = canvas.getContext('2d');

    // 1. Definir a área do diamante
    const radius = Math.max(25, Math.min(w, h) * 0.05); 
    const marginX = Math.max(15, w * 0.03); 
    const marginY = Math.max(15, h * 0.03);
    const centerX = w - marginX - (radius * 0.8); 
    const centerY = h - marginY - (radius * 0.8);

    // 2. Configuração do Patch-Based Inpainting
    const patchSize = Math.max(8, Math.floor(radius / 2.5)); // Tamanho do bloco
    const searchRadius = Math.floor(radius * 3.5); // Raio de busca para patches saudáveis
    const step = Math.floor(patchSize / 2); // Passo de sobreposição

    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const resultData = new Uint8ClampedArray(data);

    // Função auxiliar para verificar se um pixel está dentro do círculo a reparar
    const isInsideCircle = (x, y) => {
      const dx = x - centerX;
      const dy = y - centerY;
      return dx * dx + dy * dy <= radius * radius;
    };

    // Função auxiliar para calcular a diferença entre dois patches
    const comparePatches = (x1, y1, x2, y2) => {
      let diff = 0;
      for (let i = 0; i < patchSize; i++) {
        for (let j = 0; j < patchSize; j++) {
          const idx1 = ((y1 + i) * w + (x1 + j)) * 4;
          const idx2 = ((y2 + i) * w + (x2 + j)) * 4;
          // Diferença de cor (RGB)
          diff += Math.abs(data[idx1] - data[idx2]) +
                  Math.abs(data[idx1 + 1] - data[idx2 + 1]) +
                  Math.abs(data[idx1 + 2] - data[idx2 + 2]);
        }
      }
      return diff;
    };

    // Algoritmo principal
    // Itera sobre a área alvo em blocos (patches)
    for (let y = Math.floor(centerY - radius); y < centerY + radius; y += step) {
      for (let x = Math.floor(centerX - radius); x < centerX + radius; x += step) {
        
        // Verificar se o patch atual toca na área a ser reparada
        let patchTouchesTarget = false;
        for(let iy = y; iy < y + patchSize; iy++) {
            for(let ix = x; ix < x + patchSize; ix++) {
                if(isInsideCircle(ix, iy)) {
                    patchTouchesTarget = true;
                    break;
                }
            }
            if(patchTouchesTarget) break;
        }

        if (patchTouchesTarget) {
          // Encontrar o melhor patch correspondente na área circundante
          let bestPatch = { x: -1, y: -1, diff: Infinity };
          
          for (let sy = y - searchRadius; sy < y + searchRadius; sy += step) {
            for (let sx = x - searchRadius; sx < x + searchRadius; sx += step) {
              // Verificar se o patch de busca é válido e está FORA da área a reparar
              let searchPatchIsValid = true;
              if(sx < 0 || sy < 0 || sx + patchSize >= w || sy + patchSize >= h) {
                  searchPatchIsValid = false;
              } else {
                  for(let iy = sy; iy < sy + patchSize; iy++) {
                      for(let ix = sx; ix < sx + patchSize; ix++) {
                          if(isInsideCircle(ix, iy)) {
                              searchPatchIsValid = false;
                              break;
                          }
                      }
                      if(!searchPatchIsValid) break;
                  }
              }
              
              if (searchPatchIsValid) {
                const diff = comparePatches(x, y, sx, sy);
                if (diff < bestPatch.diff) {
                  bestPatch = { x: sx, y: sy, diff: diff };
                }
              }
            }
          }

          // Se encontrou um bom patch, copiar para a área alvo
          if (bestPatch.x !== -1) {
            for (let i = 0; i < patchSize; i++) {
              for (let j = 0; j < patchSize; j++) {
                const targetIdx = ((y + i) * w + (x + j)) * 4;
                const sourceIdx = ((bestPatch.y + i) * w + (bestPatch.x + j)) * 4;
                
                // Copiar apenas se o pixel de destino estiver dentro da área a reparar
                if(isInsideCircle(x + j, y + i)) {
                    resultData[targetIdx] = data[sourceIdx];
                    resultData[targetIdx + 1] = data[sourceIdx + 1];
                    resultData[targetIdx + 2] = data[sourceIdx + 2];
                    resultData[targetIdx + 3] = 255; // Alpha total
                }
              }
            }
          }
        }
      }
    }

    // 4. Atualizar Imagem e Histórico
    const finalImageData = new ImageData(resultData, w, h);
    setImage(finalImageData);
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(finalImageData);
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
    
    setLastAction("Marca removida com textura!");
    setTimeout(() => setLastAction(null), 2500);
    setIsProcessing(false);
  };

  // --- Manipulação de Gestos ---
  const handlePointerDown = (e) => {
    if (!image) return;
    if (e.touches && e.touches.length === 2) {
      isPinching.current = true;
      isDrawing.current = false;
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      startPinchDist.current = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
      startTransform.current = { ...transform };
      return;
    }
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    if (mode === 'erase') {
      isDrawing.current = true;
      hasDrawn.current = true;
      const coords = getCanvasCoordinates(clientX, clientY);
      lastDrawPos.current = coords;
      const ctx = overlayCanvasRef.current.getContext('2d');
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = brushSize; 
      ctx.strokeStyle = 'rgba(255, 0, 100, 0.7)';
      ctx.beginPath();
      ctx.moveTo(coords.x, coords.y);
      ctx.lineTo(coords.x, coords.y);
      ctx.stroke();
    } else {
      isDragging.current = true;
      startPan.current = { x: clientX, y: clientY };
      startTransform.current = { ...transform };
    }
  };

  const handlePointerMove = (e) => {
    if (!image) return;
    e.preventDefault(); 
    if (isPinching.current && e.touches && e.touches.length === 2) {
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
      const scaleFactor = dist / startPinchDist.current;
      let newScale = startTransform.current.k * scaleFactor;
      newScale = Math.max(0.1, Math.min(newScale, 5));
      setTransform(prev => ({...prev, k: newScale}));
      return;
    }
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    if (isDrawing.current && mode === 'erase') {
      const coords = getCanvasCoordinates(clientX, clientY);
      const ctx = overlayCanvasRef.current.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(lastDrawPos.current.x, lastDrawPos.current.y);
      ctx.lineTo(coords.x, coords.y);
      ctx.stroke();
      lastDrawPos.current = coords;
    } 
    else if (isDragging.current && mode === 'view') {
      const dx = clientX - startPan.current.x;
      const dy = clientY - startPan.current.y;
      setTransform({ ...transform, x: startTransform.current.x + dx, y: startTransform.current.y + dy });
    }
  };

  const handlePointerUp = () => {
    isDragging.current = false;
    isPinching.current = false;
    if (isDrawing.current) { isDrawing.current = false; applyMagicEraser(); }
  };

  // --- Algoritmo Onion Peel (Para a Borracha Manual) ---
  const applyMagicEraser = async () => {
    if (!hasDrawn.current || !image) return;
    setIsProcessing(true);
    await new Promise(r => setTimeout(r, 20)); 
    
    const canvas = imageCanvasRef.current;
    const ctx = canvas.getContext('2d');
    const overlay = overlayCanvasRef.current;
    const oCtx = overlay.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    const srcData = ctx.getImageData(0, 0, w, h).data;
    const maskData = oCtx.getImageData(0, 0, w, h).data;
    const resultData = new Uint8ClampedArray(srcData);
    const statusMap = new Int8Array(w * h); 
    const holePixels = [];
    
    for (let i = 0; i < w * h; i++) {
      if (maskData[i * 4 + 3] > 20) { statusMap[i] = 0; holePixels.push(i); }
      else { statusMap[i] = -1; }
    }
    
    if (holePixels.length > 0) {
      const neighbors = [-w, w, -1, 1, -w-1, -w+1, w-1, w+1];
      let currentBoundary = [...holePixels];
      let nextBoundary = [];
      let safety = 0;
      
      while (currentBoundary.length > 0 && safety < 1000) {
        safety++;
        nextBoundary = [];
        for (let i = 0; i < currentBoundary.length; i++) {
          const p = currentBoundary[i];
          let r=0, g=0, b=0, count=0;
          let hasValidNeighbor = false;
          
          for (let offset of neighbors) {
            const n = p + offset;
            if (n >= 0 && n < w * h && statusMap[n] === -1) {
              r += resultData[n*4];
              g += resultData[n*4+1];
              b += resultData[n*4+2];
              count++;
              hasValidNeighbor = true;
            }
          }
          
          if (hasValidNeighbor) {
            const noise = (Math.random() - 0.5) * 15;
            resultData[p*4] = (r/count) + noise;
            resultData[p*4+1] = (g/count) + noise;
            resultData[p*4+2] = (b/count) + noise;
            resultData[p*4+3] = 255;
            statusMap[p] = 1; 
          } else { nextBoundary.push(p); }
        }
        
        for (let i=0; i<w*h; i++) if (statusMap[i]===1) statusMap[i] = -1;
        
        if (nextBoundary.length === currentBoundary.length) {
            for (let p of nextBoundary) {
                resultData[p*4] = resultData[currentBoundary[0]*4];
                resultData[p*4+1] = resultData[currentBoundary[0]*4+1];
                resultData[p*4+2] = resultData[currentBoundary[0]*4+2];
                statusMap[p] = -1;
            }
            break;
        }
        currentBoundary = nextBoundary;
      }
      
      const finalImageData = new ImageData(resultData, w, h);
      setImage(finalImageData);
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(finalImageData);
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
    }
    
    oCtx.clearRect(0, 0, w, h);
    hasDrawn.current = false;
    setIsProcessing(false);
    setMode('view');
  };

  const handleUndo = () => { if (historyIndex > 0) { setHistoryIndex(historyIndex - 1); setImage(history[historyIndex - 1]); }};
  const handleRedo = () => { if (historyIndex < history.length - 1) { setHistoryIndex(historyIndex + 1); setImage(history[historyIndex + 1]); }};

  return (
    <div className="flex flex-col h-screen bg-neutral-950 text-white overflow-hidden touch-none select-none">
      <header className="flex justify-between items-center px-4 py-3 bg-neutral-900 z-50 shadow-md">
        <div className="flex items-center gap-2">
          <Sparkles className="w-5 h-5 text-pink-500" />
          <span className="font-bold text-sm md:text-base">Magic Eraser <span className="text-pink-400 text-xs">Pattern</span></span>
        </div>
        <div className="flex gap-2">
          <button onClick={() => fileInputRef.current.click()} className="p-2 bg-neutral-800 rounded-full hover:bg-neutral-700"><Upload className="w-5 h-5" /></button>
          <button onClick={saveImage} disabled={!image} className="flex items-center gap-2 px-4 py-2 bg-white text-black text-sm font-bold rounded-full disabled:opacity-50"><Download className="w-4 h-4" /> Salvar</button>
        </div>
      </header>
      
      <main ref={containerRef} className="flex-1 relative overflow-hidden bg-neutral-950 cursor-crosshair" onMouseDown={handlePointerDown} onMouseMove={handlePointerMove} onMouseUp={handlePointerUp} onMouseLeave={handlePointerUp} onTouchStart={handlePointerDown} onTouchMove={handlePointerMove} onTouchEnd={handlePointerUp}>
        {!image ? (
          <div className="absolute inset-0 flex flex-col items-center justify-center text-neutral-500 pointer-events-none"><ImageIcon className="w-12 h-12 mb-4 opacity-50"/><p className="text-sm">Carregue uma imagem</p></div>
        ) : (
          <div style={containerStyle} className="absolute top-0 left-0 origin-top-left transition-transform duration-75 ease-linear">
            <canvas ref={imageCanvasRef} className="absolute top-0 left-0 pointer-events-none" />
            <canvas ref={overlayCanvasRef} className="absolute top-0 left-0" />
          </div>
        )}
        
        {lastAction && (
          <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-green-500/90 text-white px-4 py-2 rounded-full text-sm font-bold shadow-lg animate-in fade-in slide-in-from-top-4 flex items-center gap-2 z-[60]">
            <CheckCircle2 className="w-4 h-4" /> {lastAction}
          </div>
        )}

        {isProcessing && (<div className="absolute inset-0 flex items-center justify-center bg-black/50 z-50 backdrop-blur-sm"><div className="bg-neutral-800 px-6 py-4 rounded-xl flex items-center gap-3 border border-neutral-700 shadow-xl"><div className="w-5 h-5 border-2 border-pink-500 border-t-transparent rounded-full animate-spin"></div><span>Processando...</span></div></div>)}
      </main>
      
      {image && (
        <footer className="bg-neutral-900 border-t border-neutral-800 px-4 py-4 md:py-6 z-50">
          <div className="max-w-md mx-auto flex flex-col gap-4">
            {mode === 'erase' && (<div className="flex items-center gap-3 animate-fade-in"><div className="w-6 h-6 rounded-full border border-white/20 bg-pink-500/20 text-[10px] flex items-center justify-center text-pink-400">{brushSize}</div><input type="range" min="10" max="150" value={brushSize} onChange={(e) => setBrushSize(Number(e.target.value))} className="flex-1 h-1 bg-neutral-700 rounded-lg appearance-none accent-pink-500"/></div>)}
            <div className="grid grid-cols-5 gap-2 items-center">
              <button onClick={removeWatermarkPattern} className="col-span-1 flex flex-col items-center gap-1 p-2 rounded-xl bg-purple-600/20 text-purple-400 hover:bg-purple-600 hover:text-white transition-all border border-purple-500/30 active:scale-95" title="Remover Diamond/Marca no canto inferior direito"><Gem className="w-5 h-5" /><span className="text-[9px] font-bold uppercase leading-tight text-center">Auto<br/>Remover</span></button>
              <div className="w-px h-8 bg-neutral-800 mx-auto"></div>
              <button onClick={() => setMode('erase')} className={`col-span-1 flex flex-col items-center gap-1 p-2 rounded-xl transition-all ${mode === 'erase' ? 'bg-pink-600 text-white' : 'bg-neutral-800 text-neutral-400'}`}><Eraser className="w-5 h-5" /><span className="text-[9px] font-bold uppercase">Apagar</span></button>
              <button onClick={() => setMode('view')} className={`col-span-1 flex flex-col items-center gap-1 p-2 rounded-xl transition-all ${mode === 'view' ? 'bg-blue-600 text-white' : 'bg-neutral-800 text-neutral-400'}`}><Move className="w-5 h-5" /><span className="text-[9px] font-bold uppercase">Mover</span></button>
              <div className="col-span-1 flex justify-end gap-1"><button onClick={handleUndo} disabled={historyIndex <= 0} className="p-3 bg-neutral-800 rounded-xl hover:bg-neutral-700 disabled:opacity-30"><Undo className="w-4 h-4" /></button><button onClick={handleRedo} disabled={historyIndex >= history.length - 1} className="p-3 bg-neutral-800 rounded-xl hover:bg-neutral-700 disabled:opacity-30"><Redo className="w-4 h-4" /></button></div>
            </div>
          </div>
        </footer>
      )}
      <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="image/*" className="hidden" />
    </div>
  );
}

