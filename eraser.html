<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Eraser NB - Edição de Imagem IA</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body {
            background-color: #0a0a0a;
            color: white;
            overflow: hidden; /* Previne scroll elástico no mobile */
            touch-action: none; /* Previne gestos do navegador */
        }
        /* Animações customizadas */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin-custom { animation: spin 1s linear infinite; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- ÍCONES (Inline SVG Components para evitar dependências externas complexas) ---
        const Icon = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Sparkles = ({ className }) => <Icon className={className}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 3v4"/><path d="M3 9h4"/></Icon>;
        const Upload = ({ className }) => <Icon className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></Icon>;
        const Download = ({ className }) => <Icon className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></Icon>;
        const ImageIcon = ({ className }) => <Icon className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></Icon>;
        const Eraser = ({ className }) => <Icon className={className}><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></Icon>;
        const Move = ({ className }) => <Icon className={className}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="9 19 12 22 15 19"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></Icon>;
        const Undo = ({ className }) => <Icon className={className}><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 0 0 0-6 2.3L3 13"/></Icon>;
        const Redo = ({ className }) => <Icon className={className}><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></Icon>;
        const Gem = ({ className }) => <Icon className={className}><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></Icon>;
        const CheckCircle2 = ({ className }) => <Icon className={className}><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></Icon>;

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            const [image, setImage] = useState(null);
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [brushSize, setBrushSize] = useState(40);
            const [isProcessing, setIsProcessing] = useState(false);
            const [mode, setMode] = useState('view'); // 'view' or 'erase'
            const [transform, setTransform] = useState({ k: 1, x: 0, y: 0 });
            const [lastAction, setLastAction] = useState(null);
            
            const imageCanvasRef = useRef(null);
            const overlayCanvasRef = useRef(null);
            const containerRef = useRef(null);
            const fileInputRef = useRef(null);
            
            // Controle de gestos
            const isDragging = useRef(false);
            const isPinching = useRef(false);
            const startPan = useRef({ x: 0, y: 0 });
            const startPinchDist = useRef(0);
            const startTransform = useRef({ k: 1, x: 0, y: 0 });
            
            const isDrawing = useRef(false);
            const lastDrawPos = useRef({ x: 0, y: 0 });
            const hasDrawn = useRef(false);

            // --- 1. Carregamento e Arquivos ---
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            const maxDim = 1600; 
                            let w = img.width;
                            let h = img.height;
                            if (w > maxDim || h > maxDim) {
                                const ratio = Math.min(maxDim / w, maxDim / h);
                                w *= ratio;
                                h *= ratio;
                            }
                            const canvas = document.createElement('canvas');
                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, w, h);
                            const newImageData = ctx.getImageData(0, 0, w, h);
                            
                            setImage(newImageData);
                            setHistory([newImageData]);
                            setHistoryIndex(0);
                            
                            // Ajuste inicial do zoom para caber na tela
                            if (containerRef.current) {
                                const containerW = containerRef.current.clientWidth;
                                const containerH = containerRef.current.clientHeight;
                                const scaleStart = Math.min(containerW / w, containerH / h) * 0.95;
                                const xStart = (containerW - w * scaleStart) / 2;
                                const yStart = (containerH - h * scaleStart) / 2;
                                setTransform({ k: scaleStart, x: xStart, y: yStart });
                            }
                            setMode('view');
                            setLastAction(null);
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const saveImage = async () => {
                if (!imageCanvasRef.current) return;
                try {
                    imageCanvasRef.current.toBlob((blob) => {
                        if (!blob) return;
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `magic-eraser-${Date.now()}.jpg`;
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 'image/jpeg', 0.98);
                } catch (err) { console.error(err); }
            };

            // --- 2. Renderização ---
            useEffect(() => {
                if (image && imageCanvasRef.current && overlayCanvasRef.current) {
                    const canvas = imageCanvasRef.current;
                    const ctx = canvas.getContext('2d');
                    if (canvas.width !== image.width) canvas.width = image.width;
                    if (canvas.height !== image.height) canvas.height = image.height;
                    ctx.putImageData(image, 0, 0);

                    const overlay = overlayCanvasRef.current;
                    const oCtx = overlay.getContext('2d');
                    if (overlay.width !== image.width) overlay.width = image.width;
                    if (overlay.height !== image.height) overlay.height = image.height;
                    oCtx.clearRect(0, 0, overlay.width, overlay.height);
                }
            }, [image]);

            const containerStyle = {
                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`,
                transformOrigin: '0 0',
                width: image ? image.width : 0,
                height: image ? image.height : 0,
            };

            const getCanvasCoordinates = (clientX, clientY) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const containerRect = containerRef.current.getBoundingClientRect();
                const x = (clientX - containerRect.left - transform.x) / transform.k;
                const y = (clientY - containerRect.top - transform.y) / transform.k;
                return { x, y };
            };

            // --- 3. Lógica de Reconstrução de Padrão (Patch-Based) ---
            const removeWatermarkPattern = async () => {
                if (!image || !imageCanvasRef.current) return;
                setIsProcessing(true);
                await new Promise(r => setTimeout(r, 50));

                const w = image.width;
                const h = image.height;
                const canvas = imageCanvasRef.current;
                const ctx = canvas.getContext('2d');

                // 1. Área Alvo (Canto Inferior Direito)
                const radius = Math.max(25, Math.min(w, h) * 0.05); 
                const marginX = Math.max(15, w * 0.03); 
                const marginY = Math.max(15, h * 0.03);
                const centerX = w - marginX - (radius * 0.8); 
                const centerY = h - marginY - (radius * 0.8);

                // 2. Configurações Patch-Match
                const patchSize = Math.max(8, Math.floor(radius / 2.5)); 
                const searchRadius = Math.floor(radius * 3.5); 
                const step = Math.floor(patchSize / 2); 

                const imageData = ctx.getImageData(0, 0, w, h);
                const data = imageData.data;
                const resultData = new Uint8ClampedArray(data);

                const isInsideCircle = (x, y) => {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    return dx * dx + dy * dy <= radius * radius;
                };

                const comparePatches = (x1, y1, x2, y2) => {
                    let diff = 0;
                    for (let i = 0; i < patchSize; i++) {
                        for (let j = 0; j < patchSize; j++) {
                            const idx1 = ((y1 + i) * w + (x1 + j)) * 4;
                            const idx2 = ((y2 + i) * w + (x2 + j)) * 4;
                            diff += Math.abs(data[idx1] - data[idx2]) +
                                    Math.abs(data[idx1 + 1] - data[idx2 + 1]) +
                                    Math.abs(data[idx1 + 2] - data[idx2 + 2]);
                        }
                    }
                    return diff;
                };

                for (let y = Math.floor(centerY - radius); y < centerY + radius; y += step) {
                    for (let x = Math.floor(centerX - radius); x < centerX + radius; x += step) {
                        
                        let patchTouchesTarget = false;
                        for(let iy = y; iy < y + patchSize; iy++) {
                            for(let ix = x; ix < x + patchSize; ix++) {
                                if(isInsideCircle(ix, iy)) {
                                    patchTouchesTarget = true;
                                    break;
                                }
                            }
                            if(patchTouchesTarget) break;
                        }

                        if (patchTouchesTarget) {
                            let bestPatch = { x: -1, y: -1, diff: Infinity };
                            
                            for (let sy = y - searchRadius; sy < y + searchRadius; sy += step) {
                                for (let sx = x - searchRadius; sx < x + searchRadius; sx += step) {
                                    let searchPatchIsValid = true;
                                    if(sx < 0 || sy < 0 || sx + patchSize >= w || sy + patchSize >= h) {
                                        searchPatchIsValid = false;
                                    } else {
                                        for(let iy = sy; iy < sy + patchSize; iy++) {
                                            for(let ix = sx; ix < sx + patchSize; ix++) {
                                                if(isInsideCircle(ix, iy)) {
                                                    searchPatchIsValid = false;
                                                    break;
                                                }
                                            }
                                            if(!searchPatchIsValid) break;
                                        }
                                    }
                                    
                                    if (searchPatchIsValid) {
                                        const diff = comparePatches(x, y, sx, sy);
                                        if (diff < bestPatch.diff) {
                                            bestPatch = { x: sx, y: sy, diff: diff };
                                        }
                                    }
                                }
                            }

                            if (bestPatch.x !== -1) {
                                for (let i = 0; i < patchSize; i++) {
                                    for (let j = 0; j < patchSize; j++) {
                                        const targetIdx = ((y + i) * w + (x + j)) * 4;
                                        const sourceIdx = ((bestPatch.y + i) * w + (bestPatch.x + j)) * 4;
                                        
                                        if(isInsideCircle(x + j, y + i)) {
                                            resultData[targetIdx] = data[sourceIdx];
                                            resultData[targetIdx + 1] = data[sourceIdx + 1];
                                            resultData[targetIdx + 2] = data[sourceIdx + 2];
                                            resultData[targetIdx + 3] = 255; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                const finalImageData = new ImageData(resultData, w, h);
                setImage(finalImageData);
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(finalImageData);
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
                
                setLastAction("Marca removida com textura!");
                setTimeout(() => setLastAction(null), 2500);
                setIsProcessing(false);
            };

            // --- 4. Borracha Manual (Onion Peel) ---
            const applyManualEraser = async () => {
                if (!hasDrawn.current || !image) return;
                setIsProcessing(true);
                await new Promise(r => setTimeout(r, 20)); 
                
                const canvas = imageCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const overlay = overlayCanvasRef.current;
                const oCtx = overlay.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                
                const srcData = ctx.getImageData(0, 0, w, h).data;
                const maskData = oCtx.getImageData(0, 0, w, h).data;
                const resultData = new Uint8ClampedArray(srcData);
                const statusMap = new Int8Array(w * h); 
                const holePixels = [];
                
                for (let i = 0; i < w * h; i++) {
                    if (maskData[i * 4 + 3] > 20) { statusMap[i] = 0; holePixels.push(i); }
                    else { statusMap[i] = -1; }
                }
                
                if (holePixels.length > 0) {
                    const neighbors = [-w, w, -1, 1, -w-1, -w+1, w-1, w+1];
                    let currentBoundary = [...holePixels];
                    let nextBoundary = [];
                    let safety = 0;
                    
                    while (currentBoundary.length > 0 && safety < 1000) {
                        safety++;
                        nextBoundary = [];
                        for (let i = 0; i < currentBoundary.length; i++) {
                            const p = currentBoundary[i];
                            let r=0, g=0, b=0, count=0;
                            let hasValidNeighbor = false;
                            
                            for (let offset of neighbors) {
                                const n = p + offset;
                                if (n >= 0 && n < w * h && statusMap[n] === -1) {
                                    r += resultData[n*4];
                                    g += resultData[n*4+1];
                                    b += resultData[n*4+2];
                                    count++;
                                    hasValidNeighbor = true;
                                }
                            }
                            
                            if (hasValidNeighbor) {
                                const noise = (Math.random() - 0.5) * 15;
                                resultData[p*4] = (r/count) + noise;
                                resultData[p*4+1] = (g/count) + noise;
                                resultData[p*4+2] = (b/count) + noise;
                                resultData[p*4+3] = 255;
                                statusMap[p] = 1; 
                            } else { nextBoundary.push(p); }
                        }
                        
                        for (let i=0; i<w*h; i++) if (statusMap[i]===1) statusMap[i] = -1;
                        
                        if (nextBoundary.length === currentBoundary.length) {
                            for (let p of nextBoundary) {
                                resultData[p*4] = resultData[currentBoundary[0]*4];
                                resultData[p*4+1] = resultData[currentBoundary[0]*4+1];
                                resultData[p*4+2] = resultData[currentBoundary[0]*4+2];
                                statusMap[p] = -1;
                            }
                            break;
                        }
                        currentBoundary = nextBoundary;
                    }
                    
                    const finalImageData = new ImageData(resultData, w, h);
                    setImage(finalImageData);
                    const newHistory = history.slice(0, historyIndex + 1);
                    newHistory.push(finalImageData);
                    setHistory(newHistory);
                    setHistoryIndex(newHistory.length - 1);
                }
                
                oCtx.clearRect(0, 0, w, h);
                hasDrawn.current = false;
                setIsProcessing(false);
                setMode('view');
            };

            // --- 5. Controles de Gestos ---
            const handlePointerDown = (e) => {
                if (!image) return;
                if (e.touches && e.touches.length === 2) {
                    isPinching.current = true;
                    isDrawing.current = false;
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    startPinchDist.current = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                    startTransform.current = { ...transform };
                    return;
                }
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (mode === 'erase') {
                    isDrawing.current = true;
                    hasDrawn.current = true;
                    const coords = getCanvasCoordinates(clientX, clientY);
                    lastDrawPos.current = coords;
                    const ctx = overlayCanvasRef.current.getContext('2d');
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = brushSize; 
                    ctx.strokeStyle = 'rgba(255, 0, 100, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(coords.x, coords.y);
                    ctx.lineTo(coords.x, coords.y);
                    ctx.stroke();
                } else {
                    isDragging.current = true;
                    startPan.current = { x: clientX, y: clientY };
                    startTransform.current = { ...transform };
                }
            };

            const handlePointerMove = (e) => {
                if (!image) return;
                e.preventDefault(); 
                if (isPinching.current && e.touches && e.touches.length === 2) {
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                    const scaleFactor = dist / startPinchDist.current;
                    let newScale = startTransform.current.k * scaleFactor;
                    newScale = Math.max(0.1, Math.min(newScale, 5));
                    setTransform(prev => ({...prev, k: newScale}));
                    return;
                }
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (isDrawing.current && mode === 'erase') {
                    const coords = getCanvasCoordinates(clientX, clientY);
                    const ctx = overlayCanvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(lastDrawPos.current.x, lastDrawPos.current.y);
                    ctx.lineTo(coords.x, coords.y);
                    ctx.stroke();
                    lastDrawPos.current = coords;
                } 
                else if (isDragging.current && mode === 'view') {
                    const dx = clientX - startPan.current.x;
                    const dy = clientY - startPan.current.y;
                    setTransform({ ...transform, x: startTransform.current.x + dx, y: startTransform.current.y + dy });
                }
            };

            const handlePointerUp = () => {
                isDragging.current = false;
                isPinching.current = false;
                if (isDrawing.current) { isDrawing.current = false; applyManualEraser(); }
            };

            const handleUndo = () => { if (historyIndex > 0) { setHistoryIndex(historyIndex - 1); setImage(history[historyIndex - 1]); }};
            const handleRedo = () => { if (historyIndex < history.length - 1) { setHistoryIndex(historyIndex + 1); setImage(history[historyIndex + 1]); }};

            return (
                <div className="flex flex-col h-screen bg-neutral-950 text-white overflow-hidden touch-none select-none">
                    <header className="flex justify-between items-center px-4 py-3 bg-neutral-900 z-50 shadow-md">
                        <div className="flex items-center gap-2">
                            <Sparkles className="w-5 h-5 text-pink-500" />
                            <span className="font-bold text-sm md:text-base">Magic Eraser <span className="text-pink-400 text-xs">NB</span></span>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => fileInputRef.current.click()} className="p-2 bg-neutral-800 rounded-full hover:bg-neutral-700"><Upload className="w-5 h-5" /></button>
                            <button onClick={saveImage} disabled={!image} className="flex items-center gap-2 px-4 py-2 bg-white text-black text-sm font-bold rounded-full disabled:opacity-50"><Download className="w-4 h-4" /> Salvar</button>
                        </div>
                    </header>
                    
                    <main ref={containerRef} className="flex-1 relative overflow-hidden bg-neutral-950 cursor-crosshair" onMouseDown={handlePointerDown} onMouseMove={handlePointerMove} onMouseUp={handlePointerUp} onMouseLeave={handlePointerUp} onTouchStart={handlePointerDown} onTouchMove={handlePointerMove} onTouchEnd={handlePointerUp}>
                        {!image ? (
                            <div className="absolute inset-0 flex flex-col items-center justify-center text-neutral-500 pointer-events-none text-center p-4">
                                <ImageIcon className="w-12 h-12 mb-4 opacity-50 mx-auto"/>
                                <p className="text-sm font-medium">Carregue uma imagem</p>
                                <p className="text-xs opacity-60 mt-2">Dica: Use o botão roxo para remover marcas no canto.</p>
                            </div>
                        ) : (
                            <div style={containerStyle} className="absolute top-0 left-0 origin-top-left transition-transform duration-75 ease-linear">
                                <canvas ref={imageCanvasRef} className="absolute top-0 left-0 pointer-events-none" />
                                <canvas ref={overlayCanvasRef} className="absolute top-0 left-0" />
                            </div>
                        )}
                        
                        {lastAction && (
                            <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-green-500/90 text-white px-4 py-2 rounded-full text-sm font-bold shadow-lg animate-in fade-in slide-in-from-top-4 flex items-center gap-2 z-[60]">
                                <CheckCircle2 className="w-4 h-4" /> {lastAction}
                            </div>
                        )}

                        {isProcessing && (
                            <div className="absolute inset-0 flex items-center justify-center bg-black/50 z-50 backdrop-blur-sm">
                                <div className="bg-neutral-800 px-6 py-4 rounded-xl flex items-center gap-3 border border-neutral-700 shadow-xl">
                                    <div className="w-5 h-5 border-2 border-pink-500 border-t-transparent rounded-full animate-spin-custom"></div>
                                    <span className="text-sm font-medium">Processando...</span>
                                </div>
                            </div>
                        )}
                    </main>
                    
                    {image && (
                        <footer className="bg-neutral-900 border-t border-neutral-800 px-4 py-4 md:py-6 z-50">
                            <div className="max-w-md mx-auto flex flex-col gap-4">
                                {mode === 'erase' && (
                                    <div className="flex items-center gap-3 fade-in">
                                        <div className="w-6 h-6 rounded-full border border-white/20 bg-pink-500/20 text-[10px] flex items-center justify-center text-pink-400">{brushSize}</div>
                                        <input type="range" min="10" max="150" value={brushSize} onChange={(e) => setBrushSize(Number(e.target.value))} className="flex-1 h-1 bg-neutral-700 rounded-lg appearance-none accent-pink-500"/>
                                    </div>
                                )}
                                {/* Layout Flex Responsivo em vez de Grid Fixo */}
                                <div className="flex items-center justify-between gap-2">
                                    {/* Esquerda: Auto Remover */}
                                    <button 
                                        onClick={removeWatermarkPattern} 
                                        className="flex-shrink-0 flex flex-col items-center gap-1 p-2 rounded-xl bg-purple-600/20 text-purple-400 hover:bg-purple-600 hover:text-white transition-all border border-purple-500/30 active:scale-95 w-16 sm:w-20"
                                        title="Remover Diamond/Marca no canto inferior direito"
                                    >
                                        <Gem className="w-5 h-5" />
                                        <span className="text-[9px] font-bold uppercase leading-tight text-center">Auto<br/>Remover</span>
                                    </button>

                                    {/* Centro: Ferramentas Principais */}
                                    <div className="flex-1 flex items-center justify-center gap-1 sm:gap-2">
                                        <button 
                                            onClick={() => setMode('erase')} 
                                            className={`flex-1 flex flex-col items-center gap-1 p-2 rounded-xl transition-all min-w-[3rem] ${mode === 'erase' ? 'bg-pink-600 text-white' : 'bg-neutral-800 text-neutral-400'}`}
                                        >
                                            <Eraser className="w-5 h-5" />
                                            <span className="text-[9px] font-bold uppercase">Apagar</span>
                                        </button>
                                        <button 
                                            onClick={() => setMode('view')} 
                                            className={`flex-1 flex flex-col items-center gap-1 p-2 rounded-xl transition-all min-w-[3rem] ${mode === 'view' ? 'bg-blue-600 text-white' : 'bg-neutral-800 text-neutral-400'}`}
                                        >
                                            <Move className="w-5 h-5" />
                                            <span className="text-[9px] font-bold uppercase">Mover</span>
                                        </button>
                                    </div>

                                    {/* Direita: Undo/Redo */}
                                    <div className="flex-shrink-0 flex gap-1">
                                        <button 
                                            onClick={handleUndo} 
                                            disabled={historyIndex <= 0} 
                                            className="p-3 bg-neutral-800 rounded-xl hover:bg-neutral-700 disabled:opacity-30 flex items-center justify-center w-10 h-10 sm:w-12 sm:h-12"
                                        >
                                            <Undo className="w-4 h-4" />
                                        </button>
                                        <button 
                                            onClick={handleRedo} 
                                            disabled={historyIndex >= history.length - 1} 
                                            className="p-3 bg-neutral-800 rounded-xl hover:bg-neutral-700 disabled:opacity-30 flex items-center justify-center w-10 h-10 sm:w-12 sm:h-12"
                                        >
                                            <Redo className="w-4 h-4" />
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </footer>
                    )}
                    <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="image/*" className="hidden" />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


