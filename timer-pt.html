<!DOCTYPE html>
<html lang="pt-pt" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Visual Timer Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Garante que o Tailwind obedece à classe manual 'dark'
        tailwind.config = {
            darkMode: 'class'
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
            transition: background-color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: env(safe-area-inset-top) 0.5rem env(safe-area-inset-bottom) 0.5rem;
            box-sizing: border-box;
        }

        .btn-icon {
            @apply transition-all duration-300 ease-in-out flex items-center justify-center rounded-full w-14 h-14 cursor-pointer relative;
            z-index: 50;
            background: transparent;
        }
        
        .btn-icon:hover {
            @apply bg-black/10 dark:bg-white/10 scale-110;
        }

        .btn-icon svg {
            @apply transition-transform duration-700 ease-out text-slate-500 dark:text-slate-400 pointer-events-none;
        }

        /* Rotação mecânica da engrenagem */
        #settings-btn:hover svg {
            transform: rotate(90deg);
            @apply text-slate-800 dark:text-slate-100;
        }

        /* Canvas forçado a ser um círculo perfeito */
        canvas {
            cursor: pointer;
            touch-action: none;
            display: block;
            margin: 0 auto;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
        }

        .times-up {
            animation: pulse 0.8s infinite;
        }

        /* Modal com prioridade máxima de exibição */
        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: none; /* Ativado via JS */
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            background-color: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
        }

        #notification.show {
            @apply opacity-100 scale-100;
        }
    </style>
</head>
<body class="overflow-hidden bg-yellow-100 dark:bg-slate-950 text-slate-800 dark:text-slate-100">

    <div class="app-container relative bg-yellow-100 dark:bg-slate-950 transition-colors duration-500">
        
        <!-- Alternar Tema -->
        <button id="theme-toggle" type="button" class="btn-icon absolute top-8 left-8" title="Alternar Modo Noite/Dia">
            <svg id="sun-icon" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
            </svg>
            <svg id="moon-icon" class="hidden" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
            </svg>
        </button>

        <!-- Botão de Definições -->
        <button id="settings-btn" type="button" class="btn-icon absolute top-8 right-8" title="Configurações">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3.5"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"></path>
            </svg>
        </button>

        <!-- Cabeçalho -->
        <div class="text-center mt-12 sm:mt-16">
            <p class="text-red-600 font-black tracking-[0.4em] text-sm sm:text-base mb-1 uppercase">Timer</p>
            <h1 id="time-display" class="text-7xl sm:text-8xl font-extrabold tracking-tight tabular-nums transition-colors duration-500 text-slate-800 dark:text-slate-100">00:00</h1>
            <p id="status-text" class="text-slate-500 dark:text-slate-400 font-semibold uppercase tracking-[0.15em] mt-4 text-[10px] sm:text-xs text-center">Definir tempo com o mouse ou o dedo</p>
        </div>

        <!-- Área do Disco (Garantida Circular) -->
        <div id="canvas-container" class="relative w-full flex-grow flex items-center justify-center p-4">
            <canvas id="timer-canvas"></canvas>
        </div>

        <!-- Rodapé -->
        <div class="w-full max-w-md flex gap-4 p-4 mb-8 sm:mb-16">
            <button id="reset-btn" type="button" class="flex-1 py-5 bg-white/70 dark:bg-slate-900 hover:bg-white dark:hover:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold rounded-3xl transition-all active:scale-95 text-sm tracking-widest uppercase shadow-sm border border-slate-200 dark:border-slate-800">
                Repor
            </button>
            <button id="start-btn" type="button" class="flex-[2] py-5 bg-red-500 hover:bg-red-600 text-white font-bold rounded-3xl shadow-[0_15px_30px_-5px_rgba(239,68,68,0.4)] transition-all active:scale-95 text-sm tracking-[0.15em] uppercase">
                Iniciar
            </button>
        </div>
    </div>

    <!-- Modal de Definições -->
    <div id="settings-modal" class="modal-overlay">
        <div class="bg-white dark:bg-slate-900 rounded-[2.5rem] p-10 w-full max-w-sm shadow-2xl border border-slate-100 dark:border-slate-800">
            <h2 class="text-2xl font-bold text-slate-900 dark:text-white mb-2">Definições</h2>
            <p class="text-slate-400 dark:text-slate-500 text-sm mb-8">Ajuste o limite de tempo do mostrador.</p>
            
            <div class="mb-10">
                <label class="block text-[10px] font-bold text-slate-400 mb-3 uppercase tracking-widest">Tempo Máximo (Minutos)</label>
                <div class="relative">
                    <input type="number" id="max-time-input" value="60" min="1" max="360" class="w-full p-5 bg-slate-50 dark:bg-slate-800 border-2 border-slate-100 dark:border-slate-700 rounded-2xl text-3xl font-bold text-slate-800 dark:text-white focus:outline-none focus:border-red-500 transition-colors">
                    <span class="absolute right-5 top-1/2 -translate-y-1/2 text-slate-300 dark:text-slate-600 font-bold uppercase text-sm">Min</span>
                </div>
            </div>

            <div class="flex gap-4">
                <button id="close-modal" type="button" class="flex-1 py-4 bg-slate-50 dark:bg-slate-800 text-slate-500 dark:text-slate-400 font-bold rounded-xl hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors text-xs uppercase tracking-widest">Sair</button>
                <button id="save-settings" type="button" class="flex-1 py-4 bg-slate-900 dark:bg-red-500 text-white font-bold rounded-xl hover:bg-black dark:hover:bg-red-600 transition-colors text-xs uppercase tracking-widest shadow-xl">Salvar</button>
            </div>
        </div>
    </div>

    <!-- Notificação Central -->
    <div id="notification" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-600 text-white px-12 py-10 rounded-[3.5rem] shadow-[0_25px_60px_-15px_rgba(239,68,68,0.7)] opacity-0 scale-75 transition-all duration-500 pointer-events-none font-black text-3xl sm:text-4xl z-[150] text-center border-8 border-white dark:border-slate-800 uppercase tracking-tighter whitespace-nowrap">
        Fim do Tempo!
    </div>

    <script>
        const canvas = document.getElementById('timer-canvas');
        const ctx = canvas.getContext('2d');
        const display = document.getElementById('time-display');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const notification = document.getElementById('notification');
        
        const settingsBtn = document.getElementById('settings-btn');
        const themeToggle = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        
        const settingsModal = document.getElementById('settings-modal');
        const closeModalBtn = document.getElementById('close-modal');
        const saveSettingsBtn = document.getElementById('save-settings');
        const maxTimeInput = document.getElementById('max-time-input');

        // Estado inicial
        let isDarkMode = true; 
        let totalSeconds = 0;
        let maxMinutes = 60; 
        let isRunning = false;
        let isDragging = false;
        let timerInterval = null;
        let width, height, centerX, centerY, radius;

        let audioCtx = null;
        let alarmInterval = null;
        let alarmTimeout = null;
        let isAlarming = false;

        // Alternância de Tema
        themeToggle.addEventListener('click', () => {
            isDarkMode = !isDarkMode;
            document.documentElement.classList.toggle('dark', isDarkMode);
            sunIcon.classList.toggle('hidden', !isDarkMode);
            moonIcon.classList.toggle('hidden', isDarkMode);
            draw();
        });

        // Controlo Robusto do Modal
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            initAudio();
            settingsModal.style.display = 'flex';
        });

        closeModalBtn.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        saveSettingsBtn.addEventListener('click', () => {
            const val = parseInt(maxTimeInput.value);
            if (val > 0 && val <= 360) {
                stopAlarm();
                stopTimer();
                maxMinutes = val;
                totalSeconds = 0;
                settingsModal.style.display = 'none';
                updateUI();
            }
        });

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playBeep(freq = 880, duration = 150) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration / 1000);
            osc.start();
            osc.stop(audioCtx.currentTime + duration / 1000);
        }

        function startAlarm() {
            if (isAlarming) return;
            isAlarming = true;
            playBeep(880, 300);
            alarmInterval = setInterval(() => {
                playBeep(880, 200);
                setTimeout(() => playBeep(1100, 200), 250);
            }, 1000);
            alarmTimeout = setTimeout(stopAlarm, 120000); 
        }

        function stopAlarm() {
            if (!isAlarming) return;
            isAlarming = false;
            clearInterval(alarmInterval);
            clearTimeout(alarmTimeout);
            notification.classList.remove('show');
            display.classList.remove('text-red-600', 'times-up');
        }

        function resize() {
            const container = canvas.parentElement;
            const availW = container.clientWidth;
            const availH = container.clientHeight;
            
            // Forçar forma quadrada para círculo perfeito
            const size = Math.min(availW, availH);
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            width = size;
            height = size;
            
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            centerX = width / 2;
            centerY = height / 2;
            radius = (width / 2) - 20; 
            draw();
        }

        window.addEventListener('resize', resize);
        setTimeout(resize, 100);

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function getLabelInterval(max) {
            if (max <= 2) return 0.25;
            if (max <= 5) return 0.5;
            if (max <= 15) return 1;
            if (max <= 30) return 5;
            if (max <= 60) return 5;
            if (max <= 120) return 10;
            return 30;
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            const dialColor = isDarkMode ? '#0f172a' : '#ffffff'; 
            const strokeColor = isDarkMode ? '#1e293b' : '#e2e8f0'; 
            const labelColor = isDarkMode ? '#f1f5f9' : '#475569'; 
            const majorTickColor = isDarkMode ? '#94a3b8' : '#cbd5e1'; 
            const minorTickColor = isDarkMode ? '#334155' : '#f8fafc'; 
            const centerPointColor = isDarkMode ? '#f1f5f9' : '#0f172a';

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = dialColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            const labelInterval = getLabelInterval(maxMinutes);
            const numTicks = 60; 

            for (let i = 0; i <= numTicks; i++) {
                const angle = (i / numTicks) * 2 * Math.PI - Math.PI / 2;
                const currentValue = (i / numTicks) * maxMinutes;
                const isLabelTick = Math.abs(currentValue % labelInterval) < 0.001;
                const isFiveStep = Math.abs(currentValue % (labelInterval / 5)) < 0.001;
                const tickLen = isLabelTick ? 18 : (isFiveStep ? 12 : 8);
                const x1 = centerX + (radius - tickLen) * Math.cos(angle);
                const y1 = centerY + (radius - tickLen) * Math.sin(angle);
                const x2 = centerX + radius * Math.cos(angle);
                const y2 = centerY + radius * Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = isLabelTick ? majorTickColor : minorTickColor;
                ctx.lineWidth = isLabelTick ? 3.5 : 2;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                if (isLabelTick && i < numTicks) {
                    ctx.font = '700 15px Inter';
                    ctx.fillStyle = labelColor;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let labelText = "";
                    if (labelInterval < 1) {
                        const m = Math.floor(currentValue);
                        const s = Math.round((currentValue - m) * 60);
                        labelText = s === 0 ? (m === 0 ? maxMinutes : m) : `${m}:${s.toString().padStart(2,'0')}`;
                    } else {
                        const m = Math.round(currentValue);
                        labelText = m === 0 ? maxMinutes : m;
                    }
                    const lx = centerX + (radius - 42) * Math.cos(angle);
                    const ly = centerY + (radius - 42) * Math.sin(angle);
                    ctx.fillText(labelText, lx, ly);
                }
            }

            if (totalSeconds > 0) {
                const startAngle = -Math.PI / 2;
                const maxSeconds = maxMinutes * 60;
                const endAngle = startAngle + (totalSeconds / maxSeconds) * 2 * Math.PI;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius - 1, startAngle, endAngle, false);
                ctx.closePath();
                const grad = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
                grad.addColorStop(0, 'rgba(248, 113, 113, 0.7)'); 
                grad.addColorStop(1, 'rgba(239, 68, 68, 0.7)');  
                ctx.fillStyle = grad;
                ctx.fill();
                const hx = centerX + radius * Math.cos(endAngle);
                const hy = centerY + radius * Math.sin(endAngle);
                ctx.beginPath();
                ctx.arc(hx, hy, 15, 0, 2 * Math.PI);
                ctx.fillStyle = isDarkMode ? '#0f172a' : 'white';
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 5;
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = centerPointColor;
            ctx.fill();
        }

        function handleInput(e) {
            initAudio(); 
            stopAlarm(); 
            if (isRunning && !isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const dx = x - centerX;
            const dy = y - centerY;
            let angle = Math.atan2(dy, dx) + Math.PI / 2;
            if (angle < 0) angle += 2 * Math.PI;
            const maxSeconds = maxMinutes * 60;
            let seconds = (angle / (2 * Math.PI)) * maxSeconds;
            if (!isRunning) {
                const step = maxMinutes < 12 ? 5 : 60;
                seconds = Math.round(seconds / step) * step;
            } else {
                seconds = Math.round(seconds);
            }
            if (seconds > maxSeconds) seconds = maxSeconds;
            if (seconds < 0) seconds = 0;
            totalSeconds = seconds;
            updateUI();
        }

        function updateUI() {
            display.innerText = formatTime(totalSeconds);
            draw();
            if (totalSeconds <= 0 && isRunning) {
                stopTimer();
                showNotification();
                startAlarm();
            }
        }

        function startTimer() {
            if (totalSeconds <= 0) return;
            initAudio();
            stopAlarm();
            isRunning = true;
            statusText.innerText = "Contagem Ativa";
            startBtn.innerText = "Pausar";
            startBtn.classList.replace('bg-red-500', 'bg-slate-900');
            startBtn.classList.replace('hover:bg-red-600', 'hover:bg-black');
            timerInterval = setInterval(() => {
                if (totalSeconds > 0) {
                    totalSeconds--;
                    updateUI();
                } else {
                    stopTimer();
                }
            }, 1000);
        }

        function stopTimer() {
            isRunning = false;
            clearInterval(timerInterval);
            statusText.innerText = totalSeconds > 0 ? "Pausado" : "Definir tempo com o mouse ou o dedo";
            startBtn.innerText = "Iniciar";
            startBtn.classList.replace('bg-slate-900', 'bg-red-500');
            startBtn.classList.replace('hover:bg-black', 'hover:bg-red-600');
        }

        function showNotification() {
            notification.classList.add('show');
            display.classList.add('text-red-600', 'times-up');
        }

        canvas.addEventListener('mousedown', (e) => { isDragging = true; handleInput(e); });
        window.addEventListener('mousemove', (e) => { if (isDragging) handleInput(e); });
        window.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('touchstart', (e) => { isDragging = true; handleInput(e); e.preventDefault(); }, { passive: false });
        window.addEventListener('touchmove', (e) => { if (isDragging) handleInput(e); e.preventDefault(); }, { passive: false });
        window.addEventListener('touchend', () => { isDragging = false; });
        startBtn.addEventListener('click', () => isRunning ? stopTimer() : startTimer());
        resetBtn.addEventListener('click', () => { initAudio(); stopAlarm(); stopTimer(); totalSeconds = 0; updateUI(); });

        // Inicializar resize correto
        window.onload = resize;
        updateUI();
    </script>
</body>
</html>

