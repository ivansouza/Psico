<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Spiral Clean Layout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-hint {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            z-index: 0;
            pointer-events: none;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* GUI Minimalista e Reposicionada */
        .lil-gui.root {
            position: absolute !important;
            top: auto !important;
            bottom: 10px !important; /* Bem no rodapé */
            left: 50% !important;
            transform: translateX(-50%) !important;
            right: auto !important;
            z-index: 100 !important;
            --width: 95vw !important;
            max-width: 380px;
            
            /* Fundo quase invisível */
            background-color: rgba(0, 0, 0, 0.2) !important;
            backdrop-filter: blur(2px);
            border: none;
            box-shadow: none;
        }

        .lil-gui .title {
            background: transparent;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }

        /* Ajuste para telas pequenas */
        .lil-gui { 
            --name-width: 35%;
            font-size: 12px; 
            --text-color: #ddd;
            --number-color: #0ff;
            --widget-color: rgba(255, 255, 255, 0.1);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="scene-container"></div>
    <div id="ui-hint">Toque para Girar • Pinça para Zoom</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        class App {
            constructor() {
                this.params = {
                    arms: 8,
                    loops: 15,
                    radius: 5,
                    heightMultiplier: 3.0,
                    complexity: 600, 
                    bloomStrength: 1.5,
                    bloomRadius: 0.5,
                    bloomThreshold: 0.0,
                    exposure: 1.1,
                    flowSpeed: 0.2,
                    pulseIntensity: 0.05,
                    rotationSpeed: 0.2,
                    colorSet: 'Neon'
                };

                this.colorThemes = {
                    'Neon': { A: "#000000", B: "#240046", C: "#7b2cbf", D: "#ff006e", E: "#3a86ff" },
                    'Fire': { A: "#000000", B: "#370617", C: "#6a040f", D: "#dc2f02", E: "#ffba08" },
                    'Ocean': { A: "#001219", B: "#005f73", C: "#0a9396", D: "#94d2bd", E: "#e9d8a6" },
                    'Toxic': { A: "#000000", B: "#1a1a1a", C: "#003300", D: "#39ff14", E: "#ccff00" },
                    'White': { A: "#000000", B: "#333333", C: "#666666", D: "#999999", E: "#ffffff" }
                };

                this.init();
            }

            init() {
                const container = document.getElementById("scene-container");

                // 1. Scene & Camera
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 10, 25); 

                // 2. Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = this.params.exposure;
                container.appendChild(this.renderer.domElement);

                // 3. Post Processing (Correção Mobile Mantida)
                const renderTarget = new THREE.WebGLRenderTarget(
                    window.innerWidth * window.devicePixelRatio,
                    window.innerHeight * window.devicePixelRatio,
                    {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat,
                        type: THREE.HalfFloatType,
                        stencilBuffer: false,
                        depthBuffer: true
                    }
                );

                this.composer = new EffectComposer(this.renderer, renderTarget);
                this.composer.addPass(new RenderPass(this.scene, this.camera));

                this.bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    this.params.bloomStrength,
                    this.params.bloomRadius,
                    this.params.bloomThreshold
                );
                this.composer.addPass(this.bloomPass);

                // 4. Controles
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.autoRotate = true;
                this.controls.autoRotateSpeed = this.params.rotationSpeed * 2;
                
                // MUDANÇA IMPORTANTE: Mover o centro de rotação para cima
                // Isso faz a câmera olhar para cima, deixando o objeto no topo da tela
                this.controls.target.set(0, 4, 0); 

                this.clock = new THREE.Clock();

                // 5. Setup
                this.createPattern();
                this.setupGUI();

                window.addEventListener("resize", () => this.onResize());
                this.animate();
            }

            setupGUI() {
                this.gui = new GUI({ title: 'Configurações', width: 320 });
                // Começar FECHADO para não tampar a visão
                this.gui.close(); 

                const fVisual = this.gui.addFolder('Cores e Brilho');
                fVisual.add(this.params, 'colorSet', Object.keys(this.colorThemes)).name('Tema').onChange(v => this.updateColors(v));
                fVisual.add(this.params, 'bloomStrength', 0, 3).name('Intensidade').onChange(v => this.bloomPass.strength = v);
                fVisual.close(); // Pasta fechada por padrão

                const fGeo = this.gui.addFolder('Forma');
                fGeo.add(this.params, 'arms', 1, 16, 1).name('Braços').onFinishChange(() => this.createPattern());
                fGeo.add(this.params, 'radius', 1, 15).name('Tamanho').onFinishChange(() => this.createPattern());
                fGeo.close(); // Pasta fechada por padrão
                
                const fAnim = this.gui.addFolder('Movimento');
                fAnim.add(this.params, 'flowSpeed', -2, 2).name('Fluxo').onChange(v => { if(this.mesh) this.mesh.material.uniforms.flowSpeed.value = v; });
                fAnim.add(this.params, 'rotationSpeed', -2, 2).name('Giro').onChange(v => this.controls.autoRotateSpeed = v * 10);
                fAnim.close(); // Pasta fechada por padrão
            }

            updateColors(themeName) {
                if (!this.mesh) return;
                const theme = this.colorThemes[themeName];
                const u = this.mesh.material.uniforms;
                u.colorA.value.set(theme.A);
                u.colorB.value.set(theme.B);
                u.colorC.value.set(theme.C);
                u.colorD.value.set(theme.D);
                u.colorE.value.set(theme.E);
            }

            createPattern() {
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                // MUDANÇA IMPORTANTE: Shift vertical (+4 no Y)
                const verticalShift = 4.0;

                const r = this.params.radius;
                const arms = this.params.arms;
                const loops = this.params.loops;
                const pointsPerArm = this.params.complexity; 
                const heightMult = this.params.heightMultiplier;

                const points = [];
                const indices = [];
                const radiusVariations = [];
                const angles = [];

                for (let arm = 0; arm < arms; arm++) {
                    const armOffset = (arm * Math.PI * 2) / arms;
                    for (let i = 0; i < pointsPerArm; i++) {
                        const t = i / (pointsPerArm - 1);
                        const angle = armOffset + t * Math.PI * 2 * loops;

                        const radius = r * (0.1 + 0.9 * t + 0.1 * Math.sin(t * Math.PI * 8 + arm));
                        
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        // Adicionando o shift vertical direto na geometria
                        const y = (Math.sin(t * Math.PI * 4 + angle * 0.5) * heightMult * (1.0 - t)) + verticalShift;

                        points.push(x, y, z);
                        radiusVariations.push(radius / r);
                        angles.push(angle);

                        if (i < pointsPerArm - 1) indices.push(arm * pointsPerArm + i, arm * pointsPerArm + i + 1);
                        
                        if (i % 3 === 0 && i < pointsPerArm - 20) {
                            const nextArm = (arm + 1) % arms;
                            const nextIndex = nextArm * pointsPerArm + i;
                            indices.push(arm * pointsPerArm + i, nextIndex);
                        }
                    }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                geometry.setAttribute('radiusVar', new THREE.Float32BufferAttribute(radiusVariations, 1));
                geometry.setAttribute('angle', new THREE.Float32BufferAttribute(angles, 1));
                geometry.setIndex(indices);

                const theme = this.colorThemes[this.params.colorSet];
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: this.clock.getElapsedTime() },
                        flowSpeed: { value: this.params.flowSpeed },
                        pulseIntensity: { value: this.params.pulseIntensity },
                        colorA: { value: new THREE.Color(theme.A) },
                        colorB: { value: new THREE.Color(theme.B) },
                        colorC: { value: new THREE.Color(theme.C) },
                        colorD: { value: new THREE.Color(theme.D) },
                        colorE: { value: new THREE.Color(theme.E) }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float flowSpeed;
                        uniform float pulseIntensity;
                        attribute float radiusVar;
                        attribute float angle;
                        varying vec3 vColor;
                        uniform vec3 colorA, colorB, colorC, colorD, colorE;

                        void main() {
                            vec3 pos = position;
                            float wave = sin(angle * 2.0 + time * flowSpeed);
                            pos.y += wave * pulseIntensity;
                            
                            // Efeito "Respiração"
                            pos.x += pos.x * (sin(time * 0.5) * 0.03);
                            pos.z += pos.z * (sin(time * 0.5) * 0.03);
                            
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_Position = projectionMatrix * mvPosition;

                            float t = clamp(radiusVar + wave * 0.1, 0.0, 1.0);
                            vec3 c = mix(colorA, colorB, smoothstep(0.0, 0.25, t));
                            c = mix(c, colorC, smoothstep(0.25, 0.5, t));
                            c = mix(c, colorD, smoothstep(0.5, 0.75, t));
                            c = mix(c, colorE, smoothstep(0.75, 1.0, t));
                            vColor = c * 1.8; 
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        void main() {
                            gl_FragColor = vec4(vColor, 1.0);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.LineSegments(geometry, material);
                this.scene.add(this.mesh);
            }

            onResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.camera.aspect = w / h;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(w, h);
                this.composer.setSize(w, h);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                if(this.mesh) this.mesh.material.uniforms.time.value = this.clock.getElapsedTime();
                this.controls.update();
                this.composer.render();
            }
        }

        new App();
    </script>
</body>
</html>


