<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lissajous Dystopia</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff88;
            z-index: 10;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>NEON ENTROPY v1.0</h1>
        <p>Lissajous Resonance: ACTIVE</p>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Shader do Terreno (Terra Rachada) -->
    <script id="groundVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying float vElevation;
        uniform float uTime;

        void main() {
            vUv = uv;
            vec4 modelPosition = modelMatrix * vec4(position, 1.0);
            
            // Simples ondulação de terreno
            float elevation = sin(modelPosition.x * 0.2) * cos(modelPosition.z * 0.2) * 0.5;
            modelPosition.y += elevation;
            vElevation = elevation;

            gl_Position = projectionMatrix * viewMatrix * modelPosition;
        }
    </script>

    <script id="groundFragmentShader" type="x-shader/x-fragment">
        varying vec2 vUv;
        varying float vElevation;
        uniform float uTime;

        // Função de ruído simples para rachaduras
        float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
        
        float voronoi(vec2 x) {
            vec2 n = floor(x);
            vec2 f = fract(x);
            float m = 1.0;
            for(int j=-1; j<=1; j++)
            for(int i=-1; i<=1; i++) {
                vec2 g = vec2(float(i),float(j));
                vec2 o = vec2(hash(n + g));
                vec2 r = g + o - f;
                float d = dot(r,r);
                if(d < m) m = d;
            }
            return sqrt(m);
        }

        void main() {
            vec2 uv = vUv * 20.0;
            float v = voronoi(uv);
            
            // Cor base terra escura/seca
            vec3 baseColor = vec3(0.08, 0.05, 0.02);
            // Rachaduras
            float crack = smoothstep(0.3, 0.0, v);
            vec3 crackColor = vec3(0.15, 0.1, 0.05) * crack;
            
            // Reflexo da luz neon verde vindo da curva
            float neonGlow = 1.0 / (vElevation + 2.0);
            vec3 glow = vec3(0.0, 0.2, 0.1) * neonGlow * (sin(uTime * 0.5) * 0.5 + 0.5);

            gl_FragColor = vec4(baseColor + crackColor + glow, 1.0);
        }
    </script>

    <!-- Shader da Curva de Lissajous -->
    <script id="lissajousVertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uA;
        uniform float uB;
        uniform float uDelta;
        varying float vProgress;

        void main() {
            float t = position.x + uTime * 0.5; // Usamos o X da geometria como parâmetro T
            vProgress = position.x / 6.28318;

            float x = sin(uA * t + uDelta) * 5.0;
            float y = sin(uB * t) * 5.0 + 6.0; // Elevada do chão
            float z = cos(uA * t * 0.5) * 3.0;

            vec3 newPosition = vec3(x, y, z);
            
            // Adiciona um leve balanço
            newPosition.y += sin(uTime + x) * 0.2;

            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            gl_PointSize = 4.0;
        }
    </script>

    <script id="lissajousFragmentShader" type="x-shader/x-fragment">
        varying float vProgress;
        uniform float uTime;

        void main() {
            // Neon verde pulsante
            float pulse = sin(uTime * 3.0) * 0.2 + 0.8;
            vec3 color = vec3(0.0, 1.0, 0.4) * pulse;
            
            // Efeito de rastro
            float alpha = 1.0;
            
            gl_FragColor = vec4(color, alpha);
        }
    </script>

    <script>
        let scene, camera, renderer, controls, clock;
        let groundMaterial, lissajousMaterial, skyMaterial;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            scene.fog = new THREE.FogExp2(0x020205, 0.05);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            clock = new THREE.Clock();

            createWasteland();
            createLissajous();
            createAtmosphere();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createWasteland() {
            const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);
            geometry.rotateX(-Math.PI / 2);

            groundMaterial = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('groundVertexShader').textContent,
                fragmentShader: document.getElementById('groundFragmentShader').textContent,
                uniforms: {
                    uTime: { value: 0 }
                }
            });

            const ground = new THREE.Mesh(geometry, groundMaterial);
            scene.add(ground);
        }

        function createLissajous() {
            // Criamos uma geometria baseada em pontos para a curva
            const count = 2000;
            const positions = new Float32Array(count * 3);
            for(let i = 0; i < count; i++) {
                // O valor X aqui servirá como o parâmetro 't' da curva [0, 2pi]
                positions[i * 3] = (i / count) * Math.PI * 2; 
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            lissajousMaterial = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('lissajousVertexShader').textContent,
                fragmentShader: document.getElementById('lissajousFragmentShader').textContent,
                transparent: true,
                uniforms: {
                    uTime: { value: 0 },
                    uA: { value: 3.0 },
                    uB: { value: 2.0 },
                    uDelta: { value: Math.PI / 2 }
                },
                blending: THREE.AdditiveBlending
            });

            const curve = new THREE.Points(geometry, lissajousMaterial);
            scene.add(curve);

            // Adicionar uma luz pontual fraca no centro da curva
            const light = new THREE.PointLight(0x00ff88, 2, 20);
            light.position.set(0, 6, 0);
            scene.add(light);
        }

        function createAtmosphere() {
            // Adiciona um "sol" poente e cintilante
            const sunGeom = new THREE.SphereGeometry(10, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const sun = new THREE.Mesh(sunGeom, sunMat);
            sun.position.set(0, -5, -50);
            scene.add(sun);

            // Hemisfério de luz ambiente
            const hemiLight = new THREE.HemisphereLight(0x442211, 0x050505, 0.5);
            scene.add(hemiLight);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            // Atualiza uniformes
            groundMaterial.uniforms.uTime.value = elapsedTime;
            
            lissajousMaterial.uniforms.uTime.value = elapsedTime;
            // Variando os parâmetros da curva para criar movimento
            lissajousMaterial.uniforms.uA.value = 3.0 + Math.sin(elapsedTime * 0.2) * 0.5;
            lissajousMaterial.uniforms.uB.value = 2.0 + Math.cos(elapsedTime * 0.3) * 0.5;
            lissajousMaterial.uniforms.uDelta.value += 0.01;

            // Efeito de cintilação do pôr do sol (flickering sunset)
            if (Math.random() > 0.95) {
                scene.background = new THREE.Color(0x050308);
            } else {
                scene.background = new THREE.Color(0x020205);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>