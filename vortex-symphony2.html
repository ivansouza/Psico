<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vortex Symphony: The Geometry of Infinity</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;900&display=swap');
        
        body {
            background-color: #020205;
            margin: 0;
            overflow: hidden;
            color: white;
            font-family: 'Inter', sans-serif;
        }
        canvas { display: block; }
        
        .glass-panel {
            background: rgba(10, 10, 15, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hidden-panel {
            opacity: 0;
            transform: scale(0.95) translateX(20px);
            pointer-events: none;
        }

        .ui-transition {
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            border: 2px solid #3b82f6;
        }

        select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            width: 100%;
            outline: none;
            cursor: pointer;
            appearance: none;
        }

        .label-style {
            font-size: 10px;
            margin-bottom: 4px;
            display: block;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .gear-active {
            transform: rotate(180deg);
            color: #3b82f6;
        }

        /* Tooltip for interactions */
        #hint {
            animation: fadeOut 4s forwards;
            pointer-events: none;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

    <!-- HUD Layout -->
    <div class="absolute top-8 left-8 z-10 pointer-events-none select-none">
        <div class="flex items-center gap-3">
            <div class="h-10 w-1 bg-blue-600 shadow-[0_0_15px_rgba(59,130,246,0.8)]"></div>
            <div>
                <h1 class="text-2xl font-black tracking-tighter uppercase text-white leading-none">Vortex<span class="text-blue-500">.</span>Symphony</h1>
                <p class="text-[10px] text-slate-500 font-medium tracking-[0.3em] uppercase mt-1">Spatial Geometry Engine v2.0</p>
            </div>
        </div>
    </div>

    <!-- Mouse Interaction Hint -->
    <div id="hint" class="absolute bottom-8 left-1/2 -translate-x-1/2 z-10 text-[10px] text-slate-400 tracking-widest uppercase opacity-50 text-center">
        Drag to Orbit • Scroll to Zoom • Right-Click to Pan
    </div>

    <!-- Settings Toggle -->
    <button id="toggleUI" class="absolute top-8 right-8 z-50 p-4 rounded-full glass-panel ui-transition hover:bg-white/10 active:scale-90 shadow-2xl">
        <svg id="gearIcon" class="ui-transition" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12.22 2h-.44a2 2 0 0 0-2 2 2 2 0 0 1-2 2 2 2 0 0 0-2 2 2 2 0 0 1-2 2 2 2 0 0 0-2 2v.44a2 2 0 0 0 2 2 2 2 0 0 1 2 2 2 2 0 0 0 2 2 2 2 0 0 1 2 2 2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2 2 2 0 0 1 2-2 2 2 0 0 0 2-2 2 2 0 0 1 2-2 2 2 0 0 0 2-2v-.44a2 2 0 0 0-2-2 2 2 0 0 1-2-2 2 2 0 0 0-2-2 2 2 0 0 1-2-2 2 2 0 0 0-2-2z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </button>

    <!-- Control Panel -->
    <div id="uiPanel" class="glass-panel hidden-panel ui-transition absolute top-24 right-8 w-72 p-6 rounded-3xl z-40 shadow-2xl overflow-hidden">
        <div class="space-y-6 relative">
            <div>
                <span class="label-style">Geometric Mode</span>
                <select id="presetMode">
                    <option value="galactic">Galactic Core</option>
                    <option value="helix">DNA Helix</option>
                    <option value="singularity">The Singularity</option>
                    <option value="foam">Quantum Foam</option>
                </select>
            </div>

            <div>
                <div class="flex justify-between label-style">
                    <span>Harmonic Spin</span>
                    <span id="labelFreq" class="text-white font-mono">1.00</span>
                </div>
                <input type="range" id="inputFreq" min="0.1" max="5.0" step="0.01" value="1.00">
            </div>

            <div>
                <div class="flex justify-between label-style">
                    <span>Turbulence</span>
                    <span id="labelTurb" class="text-white font-mono">0.15</span>
                </div>
                <input type="range" id="inputTurb" min="0" max="1.5" step="0.01" value="0.15">
            </div>

            <div>
                <div class="flex justify-between label-style">
                    <span>Pulse Amplitude</span>
                    <span id="labelPulse" class="text-white font-mono">0.40</span>
                </div>
                <input type="range" id="inputPulse" min="0" max="2" step="0.01" value="0.40">
            </div>

            <div>
                <div class="flex justify-between label-style">
                    <span>Time Scale</span>
                    <span id="labelSpeed" class="text-white font-mono">0.25</span>
                </div>
                <input type="range" id="inputSpeed" min="0.01" max="1.5" step="0.01" value="0.25">
            </div>

            <div class="pt-4 grid grid-cols-2 gap-3">
                <button id="resetCam" class="bg-white/5 hover:bg-white/10 text-[9px] font-black py-3 rounded-lg transition-all uppercase tracking-widest border border-white/5">Reset Cam</button>
                <button id="randomize" class="bg-blue-600/20 hover:bg-blue-600/40 text-[9px] font-black py-3 rounded-lg transition-all uppercase tracking-widest border border-blue-500/20">Chaos</button>
            </div>
        </div>
    </div>

    <!-- GLSL Shaders -->
    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uFrequency;
        uniform float uTurbulence;
        uniform float uPulse;
        uniform float uMode;

        attribute float aScale;
        attribute vec3 aRandom;

        varying vec3 vColor;
        varying float vOpacity;

        void main() {
            vec3 pos = position;

            // Base rotation
            float angle = uTime * 0.5 + pos.y * 0.5 * uFrequency;
            float c = cos(angle);
            float s = sin(angle);
            
            // Apply different geometry modes based on uMode
            if (uMode == 0.0) { // Galactic Core
                pos.x = position.x * cos(angle) - position.z * sin(angle);
                pos.z = position.x * sin(angle) + position.z * cos(angle);
            } else if (uMode == 1.0) { // Helix
                float spiral = pos.y * 2.0 + uTime;
                pos.x += cos(spiral) * 1.5;
                pos.z += sin(spiral) * 1.5;
            } else if (uMode == 2.0) { // Singularity
                float dist = length(pos);
                pos *= (1.0 + sin(uTime * 2.0 - dist * 5.0) * uPulse * 0.2);
            } else { // Foam
                pos += aRandom * sin(uTime + pos.x) * uTurbulence * 0.5;
            }

            // Global Turbulence
            pos.x += sin(pos.y * 10.0 + uTime) * uTurbulence * 0.2;
            pos.z += cos(pos.x * 10.0 + uTime) * uTurbulence * 0.2;

            // Global Pulse
            pos *= (1.0 + sin(uTime * 0.8) * uPulse * 0.1);

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = aScale * (40.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;

            // Color calculation
            float depth = (pos.y + 5.0) / 10.0;
            vColor = mix(vec3(0.1, 0.4, 1.0), vec3(0.8, 0.1, 1.0), depth);
            vColor += sin(uTime + pos.x) * 0.1; // Shimmer
            
            vOpacity = 0.8 - (length(pos) / 15.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        varying float vOpacity;

        void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            float strength = 1.0 - (r * 2.0);
            strength = pow(strength, 1.5);
            
            gl_FragColor = vec4(vColor, strength * vOpacity);
        }
    </script>

    <script>
        window.onload = function() {
            // Scene Setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x020205, 1);
            document.body.appendChild(renderer.domElement);

            // Interaction State
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0.2, targetRotationY = 0;
            let isMouseDown = false;
            let lastMouseX = 0, lastMouseY = 0;
            let zoom = 12;

            // Simulation Params
            const config = {
                count: 65000,
                freq: 1.0,
                turb: 0.15,
                pulse: 0.4,
                speed: 0.25,
                mode: 0.0 // 0: Galactic, 1: Helix, 2: Singularity, 3: Foam
            };

            // Geometry Generation
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.count * 3);
            const scales = new Float32Array(config.count);
            const randoms = new Float32Array(config.count * 3);

            for(let i = 0; i < config.count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.5) * 8;
                const h = (Math.random() - 0.5) * 10;
                
                positions[i * 3] = Math.cos(theta) * r;
                positions[i * 3 + 1] = h;
                positions[i * 3 + 2] = Math.sin(theta) * r;

                scales[i] = Math.random() * 2.0 + 0.5;
                
                randoms[i * 3] = (Math.random() - 0.5);
                randoms[i * 3 + 1] = (Math.random() - 0.5);
                randoms[i * 3 + 2] = (Math.random() - 0.5);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFrequency: { value: config.freq },
                    uTurbulence: { value: config.turb },
                    uPulse: { value: config.pulse },
                    uMode: { value: config.mode }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // UI Logic
            const elements = {
                panel: document.getElementById('uiPanel'),
                toggle: document.getElementById('toggleUI'),
                gear: document.getElementById('gearIcon'),
                freq: document.getElementById('inputFreq'),
                turb: document.getElementById('inputTurb'),
                pulse: document.getElementById('inputPulse'),
                speed: document.getElementById('inputSpeed'),
                preset: document.getElementById('presetMode'),
                lFreq: document.getElementById('labelFreq'),
                lTurb: document.getElementById('labelTurb'),
                lPulse: document.getElementById('labelPulse'),
                lSpeed: document.getElementById('labelSpeed'),
                resetCam: document.getElementById('resetCam'),
                random: document.getElementById('randomize')
            };

            let uiOpen = false;
            elements.toggle.onclick = () => {
                uiOpen = !uiOpen;
                elements.panel.classList.toggle('hidden-panel');
                elements.gear.classList.toggle('gear-active');
            };

            const updateUniforms = () => {
                material.uniforms.uFrequency.value = config.freq = parseFloat(elements.freq.value);
                material.uniforms.uTurbulence.value = config.turb = parseFloat(elements.turb.value);
                material.uniforms.uPulse.value = config.pulse = parseFloat(elements.pulse.value);
                config.speed = parseFloat(elements.speed.value);
                
                elements.lFreq.innerText = config.freq.toFixed(2);
                elements.lTurb.innerText = config.turb.toFixed(2);
                elements.lPulse.innerText = config.pulse.toFixed(2);
                elements.lSpeed.innerText = config.speed.toFixed(2);
            };

            elements.freq.oninput = updateUniforms;
            elements.turb.oninput = updateUniforms;
            elements.pulse.oninput = updateUniforms;
            elements.speed.oninput = updateUniforms;
            
            elements.preset.onchange = (e) => {
                const modes = { 'galactic': 0.0, 'helix': 1.0, 'singularity': 2.0, 'foam': 3.0 };
                material.uniforms.uMode.value = config.mode = modes[e.target.value];
            };

            elements.resetCam.onclick = () => {
                targetRotationX = 0.2; targetRotationY = 0; zoom = 12;
            };

            elements.random.onclick = () => {
                elements.freq.value = Math.random() * 4 + 0.5;
                elements.turb.value = Math.random() * 1.2;
                elements.pulse.value = Math.random() * 1.5;
                updateUniforms();
            };

            // Controls
            window.addEventListener('mousedown', (e) => { isMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
            window.addEventListener('mouseup', () => isMouseDown = false);
            window.addEventListener('mousemove', (e) => {
                if(!isMouseDown) return;
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            window.addEventListener('wheel', (e) => {
                zoom += e.deltaY * 0.01;
                zoom = Math.max(2, Math.min(30, zoom));
            });

            // Handle touch
            window.addEventListener('touchstart', (e) => { 
                isMouseDown = true; 
                lastMouseX = e.touches[0].clientX; 
                lastMouseY = e.touches[0].clientY; 
            });
            window.addEventListener('touchend', () => isMouseDown = false);
            window.addEventListener('touchmove', (e) => {
                if(!isMouseDown) return;
                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            });

            // Animation Loop
            let clock = new THREE.Clock();
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                material.uniforms.uTime.value += delta * config.speed;

                // Smoothing rotation
                points.rotation.y += (targetRotationY - points.rotation.y) * 0.1;
                points.rotation.x += (targetRotationX - points.rotation.x) * 0.1;
                
                // Smoothing zoom
                camera.position.z += (zoom - camera.position.z) * 0.1;

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        };
    </script>
</body>
</html>