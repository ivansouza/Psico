<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Dice Master 3D - Ultimate Pro</title>
    
    <!-- Bibliotecas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0a0f1e; color: white; font-family: system-ui, sans-serif; }
        
        /* FIX: Canvas sempre acessível para Orbit/Zoom */
        canvas { 
            position: fixed; top: 0; left: 0; 
            touch-action: none !important; 
            z-index: 1; cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        .ui-root { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }

        .glass {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-panel {
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
            transform: scale(0.95) translateY(-20px);
            opacity: 0; pointer-events: none;
            max-height: 85vh; overflow-y: auto;
        }
        .settings-panel.open { transform: scale(1) translateY(0); opacity: 1; pointer-events: auto; }

        input[type="range"] { 
            -webkit-appearance: none; background: rgba(255,255,255,0.1); 
            height: 4px; border-radius: 10px; width: 100%; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 18px; width: 18px;
            background: white; border-radius: 50%; cursor: pointer;
            border: 2px solid #e519b5;
        }

        .range-hue { background: linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000) !important; }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020617; display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s ease-out; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="loading-overlay">
    <div class="w-10 h-10 border-4 border-pink-500/20 border-t-pink-500 rounded-full animate-spin mb-4"></div>
    <span id="txt-loading" class="text-pink-500 font-bold text-[10px] tracking-[0.3em] uppercase">Loading Arena...</span>
</div>

<div class="ui-root">
    <!-- Result (Top-Left) -->
    <div id="resultBox" class="absolute top-4 left-4 glass px-4 py-2 rounded-xl opacity-0 transition-all duration-500 border-b-2 border-pink-500 flex flex-col items-center transform -translate-y-2">
        <span id="txt-total-label" class="text-[8px] uppercase tracking-[0.1em] text-slate-400 font-bold">Total</span>
        <span id="totalValue" class="text-2xl font-black text-white leading-tight">0</span>
        <span id="individualValues" class="text-[7px] text-pink-400 font-bold uppercase tracking-tighter mt-0.5"></span>
    </div>

    <!-- Settings Button (Top-Right) -->
    <button id="settingsBtn" class="absolute top-4 right-4 p-3 glass rounded-full active:scale-90 transition-transform shadow-lg border-white/5 border interactive">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
    </button>

    <div id="settingsPanel" class="settings-panel absolute top-20 right-4 glass p-5 rounded-[2rem] shadow-2xl w-64 flex flex-col gap-5 interactive custom-scroll">
        <h2 id="txt-settings-title" class="text-[10px] font-black uppercase tracking-widest text-pink-500 border-b border-white/10 pb-2 text-center">Settings</h2>
        
        <div class="space-y-2">
            <label id="txt-lang-label" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Language</label>
            <div class="flex gap-2">
                <button id="lang-en" class="flex-1 py-1 rounded bg-pink-600 text-[10px] font-bold">EN</button>
                <button id="lang-pt" class="flex-1 py-1 rounded bg-slate-800 text-[10px] font-bold">PT</button>
            </div>
        </div>

        <div class="space-y-3 pt-2 border-t border-white/5">
            <label id="txt-dice-metal" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Dice Metal (RGB)</label>
            <div class="space-y-1.5">
                <input type="range" id="diceR" min="0" max="255" value="0">
                <input type="range" id="diceG" min="0" max="255" value="34">
                <input type="range" id="diceB" min="0" max="255" value="183">
            </div>
        </div>

        <div class="space-y-2 pt-1 border-t border-white/5">
            <label id="txt-pips-color" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Pips Color</label>
            <input type="range" id="glowHue" min="0" max="360" value="314" class="range-hue">
        </div>

        <div class="space-y-2 pt-1 border-t border-white/5">
            <label id="txt-bg-color" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Background Color</label>
            <input type="range" id="envHue" min="0" max="360" value = "227" class="range-hue">
        </div>

        <div class="space-y-2 pt-1 border-t border-white/5">
            <div class="flex justify-between items-center">
                <label id="txt-dice-size" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Dice Size</label>
                <span id="sizeValDisplay" class="text-[8px] font-mono text-white bg-slate-700 px-1.5 py-0.5 rounded">1.4</span>
            </div>
            <input type="range" id="sizeSlider" min="0.5" max="3.0" step="0.1" value="1.4">
        </div>

        <div class="space-y-2 pt-2 border-t border-white/10">
            <div class="flex justify-between items-center">
                <label id="txt-gravity" class="text-[9px] font-black uppercase tracking-widest text-slate-400">Gravity</label>
                <span id="gravityValDisplay" class="text-[8px] font-mono text-white bg-pink-600 px-1.5 py-0.5 rounded">40</span>
            </div>
            <input type="range" id="gravitySlider" min="10" max = "120" value="40">
        </div>

        <div class="pt-4 border-t border-white/10">
            <button id="copyJsonBtn" class="w-full bg-slate-800 hover:bg-slate-700 transition-colors text-[10px] font-black py-2 rounded-lg uppercase tracking-widest flex items-center justify-center gap-2 border border-white/5">
                <span id="txt-copy-btn">Copy JSON</span>
            </button>
            <p id="copyStatus" class="text-[8px] text-green-400 text-center opacity-0 transition-opacity mt-2">Copied!</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="absolute bottom-4 left-0 w-full flex flex-col items-center px-4">
        <div class="glass p-3 px-4 rounded-[1.5rem] w-full max-w-[180px] flex flex-col gap-2 shadow-xl interactive">
            <div class="flex items-center gap-3 px-1">
                <span id="diceCountLabel" class="text-xl font-black text-pink-500 min-w-[30px] text-center">4</span>
                <input type="range" id="diceRange" min="1" max="10" value="4" class="h-1">
            </div>
            <button id="rollBtn" class="w-full bg-pink-600 active:scale-95 transition-all text-white font-black py-2 rounded-xl text-[10px] uppercase tracking-[0.2em] shadow-md shadow-pink-900/40 border-b-2 border-pink-800">
                <span id="txt-roll-btn">ROLL</span>
            </button>
        </div>
    </div>
</div>

<script>
// --- DICIONÁRIO ---
const i18n = {
    en: { loading: "Preparing Arena...", total: "Total", settings: "Settings", lang: "Language", metal: "Dice Metal (RGB)", pips: "Pips Color", bg: "Background Color", size: "Dice Size", gravity: "Gravity", copyBtn: "Copy JSON", copied: "Copied!", rollBtn: "ROLL" },
    pt: { loading: "A preparar arena...", total: "Total", settings: "Configurações", lang: "Idioma", metal: "Metal do Dado (RGB)", pips: "Cor dos Pontos", bg: "Cor do Fundo", size: "Tamanho do Dado", gravity: "Gravidade", copyBtn: "Copiar JSON", copied: "Copiado!", rollBtn: "ROLAR" }
};

const STORAGE_KEY = 'dice_master_ultimate_v1';

// --- ESTADO ---
let currentLang = 'en';
let colors = { dice: { r: 0, g: 34, b: 183 }, glow: new THREE.Color('#e519b5'), env: new THREE.Color('#0a0f1e') };
let gravityValue = 40;
let diceAmount = 4;
let diceSize = 1.4;

const tmpThreeQuat = new THREE.Quaternion();
const tmpTargetQuat = new THREE.Quaternion();

function updateUIText() {
    const t = i18n[currentLang];
    const map = { 'txt-loading': t.loading, 'txt-total-label': t.total, 'txt-settings-title': t.settings, 'txt-lang-label': t.lang, 'txt-dice-metal': t.metal, 'txt-pips-color': t.pips, 'txt-bg-color': t.bg, 'txt-dice-size': t.size, 'txt-gravity': t.gravity, 'txt-copy-btn': t.copyBtn, 'copyStatus': t.copied, 'txt-roll-btn': t.rollBtn };
    for(let id in map) { const el = document.getElementById(id); if(el) el.textContent = map[id]; }
    document.getElementById('lang-en').className = `flex-1 py-1 rounded text-[10px] font-bold ${currentLang === 'en' ? 'bg-pink-600' : 'bg-slate-800'}`;
    document.getElementById('lang-pt').className = `flex-1 py-1 rounded text-[10px] font-bold ${currentLang === 'pt' ? 'bg-pink-600' : 'bg-slate-800'}`;
}

function saveToLocal() {
    try {
        const data = { colors: { dice: colors.dice, glow: '#' + colors.glow.getHexString(), env: '#' + colors.env.getHexString() }, gravity: gravityValue, amount: diceAmount, size: diceSize, lang: currentLang, hues: { glow: document.getElementById('glowHue').value, env: document.getElementById('envHue').value } };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch(e){}
}

function loadFromLocal() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) return;
    try {
        const d = JSON.parse(saved);
        colors.dice = d.colors.dice;
        colors.glow.set(d.colors.glow);
        colors.env.set(d.colors.env);
        gravityValue = d.gravity;
        diceAmount = d.amount;
        diceSize = d.size || 1.4;
        currentLang = d.lang || 'en';
        document.getElementById('diceR').value = colors.dice.r;
        document.getElementById('diceG').value = colors.dice.g;
        document.getElementById('diceB').value = colors.dice.b;
        document.getElementById('gravitySlider').value = gravityValue;
        document.getElementById('gravityValDisplay').textContent = gravityValue;
        document.getElementById('diceRange').value = diceAmount;
        document.getElementById('diceCountLabel').textContent = diceAmount;
        document.getElementById('sizeSlider').value = diceSize;
        document.getElementById('sizeValDisplay').textContent = diceSize.toFixed(1);
        document.getElementById('glowHue').value = d.hues.glow;
        document.getElementById('envHue').value = d.hues.env;
    } catch(e) {}
}

function createRoundedBox(size, radius, segments) {
    const geometry = new THREE.BoxGeometry(size, size, size, segments, segments, segments);
    const pos = geometry.attributes.position;
    const v = new THREE.Vector3();
    const r = Math.min(radius, size * 0.3);
    for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        const x = Math.abs(v.x) - (size/2 - r);
        const y = Math.abs(v.y) - (size/2 - r);
        const z = Math.abs(v.z) - (size/2 - r);
        if (x > 0 && y > 0 && z > 0) { const m = Math.sqrt(x*x + y*y + z*z); const f = (r - m) / m; v.x += (v.x > 0 ? x : -x) * f; v.y += (v.y > 0 ? y : -y) * f; v.z += (v.z > 0 ? z : -z) * f; }
        else if (x > 0 && y > 0) { const m = Math.sqrt(x*x + y*y); const f = (r - m) / m; v.x += (v.x > 0 ? x : -x) * f; v.y += (v.y > 0 ? y : -y) * f; }
        else if (x > 0 && z > 0) { const m = Math.sqrt(x*x + z*z); const f = (r - m) / m; v.x += (v.x > 0 ? x : -x) * f; v.z += (v.z > 0 ? z : -z) * f; }
        else if (y > 0 && z > 0) { const m = Math.sqrt(y*y + z*z); const f = (r - m) / m; v.y += (v.y > 0 ? y : -y) * f; v.z += (v.z > 0 ? z : -z) * f; }
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    geometry.computeVertexNormals();
    return geometry;
}

function init() {
    loadFromLocal();
    updateUIText();

    const scene = new THREE.Scene();
    scene.background = colors.env;
    scene.fog = new THREE.Fog(colors.env, 20, 80);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 35, 30);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI / 2.1;

    const world = new CANNON.World();
    world.gravity.set(0, -gravityValue, 0);
    world.allowSleep = true; 
    
    const diceMaterial = new CANNON.Material();
    const floorMaterial = new CANNON.Material();
    const contactMaterial = new CANNON.ContactMaterial(diceMaterial, floorMaterial, { friction: 0.8, restitution: 0.05, contactEquationStiffness: 1e8 });
    world.addContactMaterial(contactMaterial);

    const floorBody = new CANNON.Body({ mass: 0, material: floorMaterial });
    floorBody.addShape(new CANNON.Plane());
    floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
    world.addBody(floorBody);

    const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 1.0 }));
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(20, 50, 20); sun.castShadow = true;
    sun.shadow.camera.top = 40; sun.shadow.camera.bottom = -40;
    sun.shadow.camera.left = -40; sun.shadow.camera.right = 40;
    sun.shadow.mapSize.set(2048, 2048); sun.shadow.bias = -0.0005;
    scene.add(sun);

    let diceGeom = createRoundedBox(diceSize, diceSize * 0.3, 12);
    let diceArray = [];

    function getMat(n) {
        const can = document.createElement('canvas'); can.width = 256; can.height = 256;
        const c = can.getContext('2d');
        const dHex = "#" + ((1 << 24) + (colors.dice.r << 16) + (colors.dice.g << 8) + colors.dice.b).toString(16).slice(1);
        c.fillStyle = dHex; c.fillRect(0,0,256,256);
        c.fillStyle = '#' + colors.glow.getHexString();
        const dot = (x,y) => { c.beginPath(); c.arc(x,y,34,0,Math.PI*2); c.fill(); c.fillStyle = '#fff'; c.beginPath(); c.arc(x-7,y-7,10,0,Math.PI*2); c.fill(); c.fillStyle = '#' + colors.glow.getHexString(); };
        const m=128, l=64, r=192;
        if(n==1) dot(m,m); if(n==2){dot(l,l);dot(r,r);} if(n==3){dot(l,l);dot(m,m);dot(r,r);}
        if(n==4){dot(l,l);dot(r,l);dot(l,r);dot(r,r);} if(n==5){dot(l,l);dot(r,l);dot(l,r);dot(r,r);dot(m,m);}
        if(n==6){dot(l,l);dot(r,l);dot(l,r);dot(r,r);dot(l,m);dot(r,m);}
        const tex = new THREE.CanvasTexture(can);
        return new THREE.MeshStandardMaterial({ map: tex, metalness: 0.9, roughness: 0.1, emissive: colors.glow, emissiveIntensity: 1.2, emissiveMap: tex });
    }

    let currentMats = [];
    const refreshMats = () => currentMats = [2,5,1,6,3,4].map(n => getMat(n));
    refreshMats();

    const spawn = (num) => {
        diceArray.forEach(d => { scene.remove(d.mesh); world.remove(d.body); });
        diceArray = [];
        document.getElementById('resultBox').style.opacity = '0';
        diceGeom.dispose(); diceGeom = createRoundedBox(diceSize, diceSize * 0.3, 12);
        for (let i = 0; i < num; i++) {
            const mesh = new THREE.Mesh(diceGeom, currentMats);
            mesh.castShadow = mesh.receiveShadow = true; scene.add(mesh);
            const body = new CANNON.Body({ mass: 25 * diceSize, material: diceMaterial, shape: new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)), linearDamping: 0.45, angularDamping: 0.55, sleepSpeedLimit: 1.8, sleepTimeLimit: 0.3 });
            body.position.set((Math.random()-0.5)*5.0, 15+i*4, (Math.random()-0.5)*5.0);
            body.velocity.set((Math.random()-0.5)*15, -gravityValue*0.6, (Math.random()-0.5)*15);
            body.angularVelocity.set((Math.random()-0.5)*130, (Math.random()-0.5)*130, (Math.random()-0.5)*130);
            world.addBody(body); diceArray.push({ mesh, body });
        }
    };

    const faceMap = [ {v: [1,0,0], n: 2}, {v: [-1,0,0], n: 5}, {v: [0,1,0], n: 1}, {v: [0,-1,0], n: 6}, {v: [0,0,1], n: 3}, {v: [0,0,-1], n: 4} ];

    function forceFinalLanding(d) {
        const vel = d.body.velocity.length();
        const aVel = d.body.angularVelocity.length();
        if (vel < 1.8 && aVel < 1.8) {
            let maxDot = -1, bestFace = null;
            tmpThreeQuat.set(d.body.quaternion.x, d.body.quaternion.y, d.body.quaternion.z, d.body.quaternion.w);
            faceMap.forEach(f => { const dot = new THREE.Vector3(...f.v).applyQuaternion(tmpThreeQuat).dot(new THREE.Vector3(0, 1, 0)); if (dot > maxDot) { maxDot = dot; bestFace = f; } });
            if (maxDot < 0.9995) {
                tmpTargetQuat.setFromUnitVectors(new THREE.Vector3(...bestFace.v), new THREE.Vector3(0, 1, 0));
                tmpThreeQuat.slerp(tmpTargetQuat, 0.25);
                d.body.quaternion.set(tmpThreeQuat.x, tmpThreeQuat.y, tmpThreeQuat.z, tmpThreeQuat.w);
                if (vel < 0.4 && aVel < 0.4) d.body.angularVelocity.set((Math.random()-0.5)*2, 0.5, (Math.random()-0.5)*2);
            } else { d.body.sleep(); }
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        world.step(1/60);
        let allStopped = true, total = 0, results = [];
        diceArray.forEach(d => {
            d.mesh.position.set(d.body.position.x, d.body.position.y, d.body.position.z);
            d.mesh.quaternion.set(d.body.quaternion.x, d.body.quaternion.y, d.body.quaternion.z, d.body.quaternion.w);
            forceFinalLanding(d);
            if (d.body.sleepState !== CANNON.Body.SLEEPING) allStopped = false;
            else { let max = -1, val = 0; faceMap.forEach(f => { const dot = new THREE.Vector3(...f.v).applyQuaternion(d.mesh.quaternion).dot(new THREE.Vector3(0,1,0)); if(dot > max){ max = dot; val = f.n; } }); total += val; results.push(val); }
        });
        if (allStopped && diceArray.length > 0) {
            document.getElementById('totalValue').textContent = total;
            document.getElementById('individualValues').textContent = results.join(' + ');
            document.getElementById('resultBox').style.opacity = '1';
            document.getElementById('resultBox').style.transform = 'translateY(8px)';
        }
        controls.update(); renderer.render(scene, camera);
    }

    animate(); spawn(diceAmount);

    // Handlers
    document.getElementById('rollBtn').onclick = () => { diceAmount = parseInt(document.getElementById('diceRange').value); spawn(diceAmount); saveToLocal(); };
    document.getElementById('diceRange').oninput = (e) => document.getElementById('diceCountLabel').textContent = e.target.value;
    document.getElementById('settingsBtn').onclick = () => document.getElementById('settingsPanel').classList.toggle('open');
    document.getElementById('copyJsonBtn').onclick = () => { const config = { dice_metal_rgb: colors.dice, glow_hex: '#' + colors.glow.getHexString(), env_hex: '#' + colors.env.getHexString(), gravity: gravityValue, dice_amount: diceAmount, dice_size: diceSize, language: currentLang }; const el = document.createElement("textarea"); el.value = JSON.stringify(config, null, 2); document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el); const s = document.getElementById('copyStatus'); s.style.opacity = '1'; setTimeout(() => s.style.opacity = '0', 2000); };
    ['R', 'G', 'B'].forEach(axis => { document.getElementById('dice' + axis).oninput = (e) => { colors.dice[axis.toLowerCase()] = parseInt(e.target.value); refreshMats(); diceArray.forEach(d => d.mesh.material = currentMats); saveToLocal(); }; });
    document.getElementById('glowHue').oninput = (e) => { colors.glow.setHSL(parseInt(e.target.value)/360, 0.8, 0.5); refreshMats(); diceArray.forEach(d => d.mesh.material = currentMats); saveToLocal(); };
    document.getElementById('envHue').oninput = (e) => { colors.env.setHSL(parseInt(e.target.value)/360, 0.4, 0.1); scene.background.copy(colors.env); scene.fog.color.copy(colors.env); document.body.style.background = '#' + colors.env.getHexString(); saveToLocal(); };
    document.getElementById('gravitySlider').oninput = (e) => { gravityValue = parseInt(e.target.value); document.getElementById('gravityValDisplay').textContent = gravityValue; world.gravity.set(0, -gravityValue, 0); saveToLocal(); };
    document.getElementById('sizeSlider').oninput = (e) => { diceSize = parseFloat(e.target.value); document.getElementById('sizeValDisplay').textContent = diceSize.toFixed(1); saveToLocal(); spawn(diceAmount); };
    document.getElementById('lang-en').onclick = () => { currentLang = 'en'; updateUIText(); saveToLocal(); };
    document.getElementById('lang-pt').onclick = () => { currentLang = 'pt'; updateUIText(); saveToLocal(); };
    window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    
    // Failsafe para loader
    setTimeout(() => { 
        document.getElementById('loading-overlay').style.opacity = '0';
        setTimeout(() => document.getElementById('loading-overlay').style.display = 'none', 500);
    }, 1200);
}

window.onerror = () => {
    const loader = document.getElementById('loading-overlay');
    if(loader) { loader.style.opacity = '0'; setTimeout(() => loader.style.display = 'none', 500); }
};

window.onload = init;
</script>
</body>
</html>