<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Springs - Customizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; }
        canvas { display: block; }
        .glass {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: white;
            font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
        }
        .interactive { pointer-events: auto; }
        
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            transition: transform 0.3s ease;
            z-index: 100;
        }
        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <!-- Overlay de Título -->
    <div class="ui-overlay">
        <h1 class="text-2xl font-bold tracking-tight">Oscilador Cinético</h1>
        <p class="text-slate-400 text-sm">Use 1 dedo para girar • 2 dedos para zoom</p>
    </div>

    <!-- Botão de Engrenagem -->
    <button id="settingsBtn" class="fixed top-5 right-5 z-50 p-3 rounded-full glass interactive hover:bg-white/20 transition-all text-white">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
    </button>

    <!-- Janela de Configurações -->
    <div id="settingsPanel" class="fixed top-20 right-5 z-40 w-64 glass rounded-2xl p-6 text-white transform translate-x-[120%] transition-transform duration-300 interactive shadow-2xl overflow-y-auto max-h-[80vh]">
        <h2 class="text-lg font-semibold mb-4 border-b border-white/10 pb-2">Configurações</h2>
        
        <div class="mb-5">
            <label class="text-xs uppercase tracking-wider text-slate-400 mb-2 block">Formato do Objeto</label>
            <select id="shapeSelect" class="w-full bg-slate-800 border border-white/10 rounded-lg p-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="sphere">Esfera</option>
                <option value="box">Cubo</option>
                <option value="pyramid">Pirâmide</option>
            </select>
        </div>

        <div class="space-y-4 mb-6">
            <div>
                <label class="text-xs uppercase tracking-wider text-slate-400 mb-1 block">Cor dos Objetos</label>
                <input type="color" id="ballColor" value="#ff0000" class="w-full h-8 bg-transparent cursor-pointer rounded">
            </div>
            <div>
                <label class="text-xs uppercase tracking-wider text-slate-400 mb-1 block">Cor das Molas</label>
                <input type="color" id="springColor" value="#ffff00" class="w-full h-8 bg-transparent cursor-pointer rounded">
            </div>
        </div>

        <div class="space-y-2 pt-4 border-t border-white/10">
            <button id="saveBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                Salvar Padrão
            </button>
            <button id="copyBtn" class="w-full bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium py-2 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                Copiar JSON
            </button>
        </div>
    </div>

    <!-- Toast de Feedback -->
    <div id="toast" class="glass px-6 py-3 rounded-full text-white text-sm shadow-xl border border-white/20">
        Configurações copiadas!
    </div>

    <!-- Three.js e OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, clock, controls;
        let springs = [];
        let objects = [];
        
        // --- Parâmetros Iniciais Solicitados ---
        const initialParams = {
            shape: "sphere",
            ballColor: "#ff0000",
            springColor: "#ffff00",
            physics: {
                springs: 36,
                restLength: 6,
                amplitude: 2.5,
                frequency: 1.5
            }
        };

        const numSprings = initialParams.physics.springs; 
        const restLength = initialParams.physics.restLength;
        const amplitude = initialParams.physics.amplitude;
        const frequency = initialParams.physics.frequency;
        const phaseShift = 0.2;
        const pedestalHeight = 0.5;

        // Estado do Customizador (Inicializado com parâmetros solicitados)
        let currentShape = initialParams.shape;
        let currentBallColor = new THREE.Color(initialParams.ballColor);
        let currentSpringColor = new THREE.Color(initialParams.springColor);

        function loadSavedSettings() {
            const saved = localStorage.getItem('physics_sim_settings');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    currentShape = data.shape || currentShape;
                    currentBallColor = new THREE.Color(data.ballColor || initialParams.ballColor);
                    currentSpringColor = new THREE.Color(data.springColor || initialParams.springColor);
                } catch(e) { console.error(e); }
            }
            // Atualiza inputs da UI
            document.getElementById('shapeSelect').value = currentShape;
            document.getElementById('ballColor').value = '#' + currentBallColor.getHexString();
            document.getElementById('springColor').value = '#' + currentSpringColor.getHexString();
        }

        function init() {
            loadSavedSettings();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            scene.fog = new THREE.Fog(0x0f172a, 10, 60);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.target.set(0, pedestalHeight / 2, 0);

            clock = new THREE.Clock();

            // Luzes
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            scene.add(mainLight);

            const fillLight = new THREE.PointLight(0x38bdf8, 1, 50);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);

            // Chão e Grid
            const grid = new THREE.GridHelper(100, 50, 0x334155, 0x1e293b);
            grid.position.y = -0.01;
            scene.add(grid);

            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.ShadowMaterial({ opacity: 0.3 })
            );
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Pedestal
            const pedestal = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.5, pedestalHeight, 32),
                new THREE.MeshStandardMaterial({ color: 0x334155, metalness: 0.8, roughness: 0.2 })
            );
            pedestal.position.y = pedestalHeight / 2;
            pedestal.castShadow = true;
            pedestal.receiveShadow = true;
            scene.add(pedestal);

            createSpringSystem();
            setupUI();

            window.addEventListener('resize', onWindowResize);
        }

        function getGeometry(type) {
            switch(type) {
                case 'box': return new THREE.BoxGeometry(0.6, 0.6, 0.6);
                case 'pyramid': return new THREE.ConeGeometry(0.4, 0.7, 4);
                default: return new THREE.SphereGeometry(0.35, 32, 32);
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 2000);
        }

        function setupUI() {
            const panel = document.getElementById('settingsPanel');
            const btn = document.getElementById('settingsBtn');
            let visible = false;

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                visible = !visible;
                panel.style.transform = visible ? 'translateX(0)' : 'translateX(120%)';
            });

            document.getElementById('shapeSelect').addEventListener('change', (e) => {
                currentShape = e.target.value;
                const newGeo = getGeometry(currentShape);
                objects.forEach(obj => {
                    obj.geometry.dispose();
                    obj.geometry = newGeo;
                    if(currentShape === 'pyramid') obj.rotation.x = Math.PI;
                });
            });

            document.getElementById('ballColor').addEventListener('input', (e) => {
                currentBallColor.set(e.target.value);
                objects.forEach(obj => {
                    obj.material.color.copy(currentBallColor);
                    obj.material.emissive.copy(currentBallColor);
                });
            });

            document.getElementById('springColor').addEventListener('input', (e) => {
                currentSpringColor.set(e.target.value);
                springs.forEach(s => {
                    s.mesh.material.color.copy(currentSpringColor);
                });
            });

            document.getElementById('saveBtn').addEventListener('click', () => {
                const settings = {
                    shape: currentShape,
                    ballColor: '#' + currentBallColor.getHexString(),
                    springColor: '#' + currentSpringColor.getHexString()
                };
                localStorage.setItem('physics_sim_settings', JSON.stringify(settings));
                showToast("Padrão salvo!");
            });

            document.getElementById('copyBtn').addEventListener('click', () => {
                const settings = {
                    shape: currentShape,
                    ballColor: '#' + currentBallColor.getHexString(),
                    springColor: '#' + currentSpringColor.getHexString(),
                    physics: {
                        springs: numSprings,
                        restLength: restLength,
                        amplitude: amplitude,
                        frequency: frequency
                    }
                };
                const json = JSON.stringify(settings, null, 2);
                const textArea = document.createElement("textarea");
                textArea.value = json;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast("Parâmetros copiados!");
                } catch (err) { console.error(err); }
                document.body.removeChild(textArea);
            });
        }

        function createSpringSystem() {
            const tubeRadius = 0.04;
            const helixRadius = 0.2;
            const turns = 12;

            for (let i = 0; i < numSprings; i++) {
                const angle = (i / numSprings) * Math.PI * 2;
                const dirX = Math.cos(angle);
                const dirZ = Math.sin(angle);
                
                class SpringCurve extends THREE.Curve {
                    constructor(h) { super(); this.height = h; }
                    getPoint(t) {
                        const theta = t * Math.PI * 2 * turns;
                        const r = helixRadius * (1 - Math.pow(t, 10)); 
                        return new THREE.Vector3(Math.cos(theta) * r, Math.sin(theta) * r, t * this.height);
                    }
                }

                const springMesh = new THREE.Mesh(
                    new THREE.TubeGeometry(new SpringCurve(restLength), 128, tubeRadius, 8, false),
                    new THREE.MeshStandardMaterial({ 
                        color: currentSpringColor, metalness: 0.9, roughness: 0.1,
                        emissive: currentBallColor, emissiveIntensity: 0.1
                    })
                );
                springMesh.castShadow = true;
                
                const container = new THREE.Group();
                container.position.set(0, pedestalHeight, 0); 
                container.lookAt(new THREE.Vector3(dirX, pedestalHeight, dirZ));
                container.add(springMesh);
                scene.add(container);

                const obj = new THREE.Mesh(
                    getGeometry(currentShape),
                    new THREE.MeshStandardMaterial({ 
                        color: currentBallColor, metalness: 0.8, roughness: 0.2,
                        emissive: currentBallColor, emissiveIntensity: 0.5
                    })
                );
                if(currentShape === 'pyramid') obj.rotation.x = Math.PI;
                obj.castShadow = true;
                scene.add(obj);

                springs.push({ mesh: springMesh, angle, dirX, dirZ, phase: i * phaseShift });
                objects.push(obj);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            for (let i = 0; i < numSprings; i++) {
                const s = springs[i];
                const obj = objects[i];
                const currentDist = restLength + Math.sin(time * frequency + s.phase) * amplitude;
                
                s.mesh.scale.set(1, 1, currentDist / restLength);
                obj.position.set(s.dirX * currentDist, pedestalHeight, s.dirZ * currentDist);

                if(currentShape !== 'sphere') obj.rotation.y += 0.02;

                const stress = (currentDist - (restLength - amplitude)) / (amplitude * 2);
                s.mesh.material.emissiveIntensity = 0.05 + stress * 0.4;
                obj.material.emissiveIntensity = 0.3 + stress * 1.2;
            }
            renderer.render(scene, camera);
        }

        window.onload = init;
        animate();
    </script>
</body>
</html>