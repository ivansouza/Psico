<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ouroboros - Execução Final</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }

        /* Botão da Engrenagem */
        #gear-btn {
            position: absolute; top: 20px; right: 20px;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%; color: white; font-size: 24px;
            cursor: pointer; backdrop-filter: blur(5px);
            z-index: 100; transition: all 0.3s ease;
            display: flex; align-items: center; justify-content: center;
        }
        #gear-btn:hover { background: rgba(255, 255, 255, 0.3); transform: rotate(90deg); }

        /* Painel de Configurações */
        #settings-panel {
            position: absolute; top: 80px; right: 20px; width: 320px;
            background: rgba(10, 10, 15, 0.95); backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 12px;
            padding: 20px; color: white; z-index: 99;
            transform: translateX(120%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
        #settings-panel.active { transform: translateX(0); }

        .control-group { margin-bottom: 15px; }
        .control-header { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .control-header label { font-size: 11px; color: #aaa; text-transform: uppercase; }
        .value-display { font-size: 12px; color: #00d2ff; font-weight: bold; }

        input[type=range] {
            width: 100%; -webkit-appearance: none; background: rgba(255,255,255,0.1);
            height: 4px; border-radius: 2px; outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #00d2ff; cursor: pointer;
        }
    </style>
</head>
<body>

    <button id="gear-btn"><i class="fa-solid fa-gear"></i></button>

    <div id="settings-panel">
        <div class="control-group">
            <div class="control-header"><label>Tamanho da Curva (Ponta)</label><span id="val-tip">0.01</span></div>
            <input type="range" id="inp-tip" min="0.01" max="0.3" step="0.01" value="0.01">
        </div>
        <div class="control-group">
            <div class="control-header"><label>Espessura Parede</label><span id="val-thick">4.20</span></div>
            <input type="range" id="inp-thick" min="0.5" max="6.0" step="0.1" value="4.20">
        </div>
        <div class="control-group">
            <div class="control-header"><label>Raio Externo</label><span id="val-outer">7.60</span></div>
            <input type="range" id="inp-outer" min="4.0" max="12.0" step="0.1" value="7.60">
        </div>
        <div class="control-group">
            <div class="control-header"><label>Abertura (Gap)</label><span id="val-gap">30.00</span></div>
            <input type="range" id="inp-gap" min="0.0" max="40.0" step="0.5" value="30.00">
        </div>
        <div class="control-group">
            <div class="control-header"><label>Comprimento</label><span id="val-len">8.20</span></div>
            <input type="range" id="inp-len" min="1.0" max="12.0" step="0.1" value="8.20">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- LÓGICA DA UI ---
        const btn = document.getElementById('gear-btn');
        const panel = document.getElementById('settings-panel');
        
        btn.addEventListener('click', () => {
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                btn.style.transform = 'rotate(180deg)';
                btn.style.background = 'rgba(255, 255, 255, 0.3)';
            } else {
                btn.style.transform = 'rotate(0deg)';
                btn.style.background = 'rgba(255, 255, 255, 0.1)';
            }
        });

        function bind(id, uniformName, displayId) {
            const input = document.getElementById(id);
            const display = document.getElementById(displayId);
            
            input.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                display.innerText = val.toFixed(2);
                if (material && material.uniforms[uniformName]) {
                    material.uniforms[uniformName].value = val;
                }
            });
        }

        // --- Configuração Three.js ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(40, -60, 30); // Câmera ajustada para o GAP grande
        camera.up.set(0,0,1);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Textura ---
        const createTex = () => {
            const c = document.createElement('canvas');
            c.width=32; c.height=32;
            const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.6)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        };

        // --- Geometria (70k partículas - Seguro e Denso) ---
        const count = 70000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const attr = {
            rnd: new Float32Array(count),
            t: new Float32Array(count),
            phi: new Float32Array(count),
            wall: new Float32Array(count), 
            angle: new Float32Array(count) 
        };

        for(let i=0; i<count; i++){
            attr.rnd[i] = Math.random();
            attr.t[i] = Math.random();
            attr.phi[i] = Math.random() * Math.PI * 2;
            attr.angle[i] = Math.random() * Math.PI * 2;
            // Distribuição linear na parede: -0.5 (Dentro) a 0.5 (Fora)
            attr.wall[i] = Math.random() - 0.5; 
            pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        geo.setAttribute('aRnd', new THREE.BufferAttribute(attr.rnd,1));
        geo.setAttribute('aT', new THREE.BufferAttribute(attr.t,1));
        geo.setAttribute('aPhi', new THREE.BufferAttribute(attr.phi,1));
        geo.setAttribute('aWall', new THREE.BufferAttribute(attr.wall,1));
        geo.setAttribute('aAngle', new THREE.BufferAttribute(attr.angle,1));

        // --- Shader ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTex: { value: createTex() },
                // --- PARÂMETROS INICIAIS SOLICITADOS ---
                uTipSize: { value: 0.01 },  // Curva curta
                uThick: { value: 4.20 },    // Parede grossa
                uOuterR: { value: 7.60 },   // Raio Externo
                uGap: { value: 30.00 },     // Abertura grande
                uLength: { value: 8.20 }    // Comprimento
            },
            vertexShader: `
                uniform float uTime;
                uniform float uOuterR;
                uniform float uThick;
                uniform float uGap;
                uniform float uLength;
                uniform float uTipSize;

                attribute float aRnd;
                attribute float aT;
                attribute float aPhi;
                attribute float aWall; 
                attribute float aAngle;

                varying vec3 vColor;
                varying float vAlpha;

                const float PI = 3.14159265;

                mat2 rotate(float a) {
                    float s=sin(a), c=cos(a);
                    return mat2(c,-s,s,c);
                }

                void main() {
                    // Proteção contra divisão por zero se uTipSize for muito pequeno
                    float safeTip = max(uTipSize, 0.001);

                    // --- 1. Lógica da Curvatura (Ponta) ---
                    float tMap = aT;
                    float curlAngle = 0.0;
                    float tipStart = safeTip;
                    float tipEnd = 1.0 - safeTip;

                    if (aT < tipStart) {
                        float p = aT / tipStart; 
                        curlAngle = (p - 1.0) * PI; 
                        tMap = tipStart; 
                    } 
                    else if (aT > tipEnd) {
                        float p = (aT - tipEnd) / safeTip;
                        curlAngle = p * PI;
                        tMap = tipEnd;
                    }

                    // --- 2. Esqueleto ---
                    float theta = (tMap - 0.5) * uLength;
                    float majorR = 14.0;
                    vec3 center = vec3(
                        majorR * cos(theta),
                        majorR * sin(theta),
                        (theta / uLength) * uGap
                    );

                    // --- 3. Vetores ---
                    vec3 T = normalize(vec3(-sin(theta), cos(theta), uGap/(uLength*majorR)));
                    vec3 N = vec3(cos(theta), sin(theta), 0.0);
                    vec3 B = normalize(cross(T, N));
                    N = normalize(cross(B, T));

                    // --- 4. Geometria Parede ---
                    float xRel = aWall * uThick; 
                    float yRel = 0.0; 

                    // Rotação Física
                    if (abs(curlAngle) > 0.001) {
                        float c = cos(curlAngle);
                        float s = sin(curlAngle);
                        float xNew = xRel * c - yRel * s;
                        float yNew = xRel * s + yRel * c;
                        xRel = xNew;
                        yRel = yNew;
                    }

                    float rMid = uOuterR - (uThick * 0.5);
                    float rFinal = rMid + xRel; 

                    // --- 5. Montagem ---
                    float sectionAngle = aAngle + aPhi + theta;
                    vec3 pipeRadial = N * cos(sectionAngle) + B * sin(sectionAngle);
                    
                    vec3 pos = center;
                    pos += pipeRadial * rFinal;
                    pos += T * yRel;

                    pos.xy *= rotate(uTime * 0.1);

                    vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mv;
                    
                    // Tamanho das partículas um pouco maior para preencher o gap
                    gl_PointSize = (5.0 * aRnd + 2.0) * (60.0 / -mv.z);

                    // --- 6. Cores ---
                    // xRel > 0: Externo (Ciano)
                    // xRel < 0: Interno (Magenta)
                    
                    float wallMix = (xRel / (uThick * 0.5)) * 0.5 + 0.5;
                    wallMix = clamp(wallMix, 0.0, 1.0);
                    
                    vec3 cOut = vec3(0.0, 1.0, 1.0); 
                    vec3 cIn = vec3(1.0, 0.0, 0.5);
                    vec3 col = mix(cIn, cOut, wallMix);
                    
                    // Pulso
                    float dir = sign(xRel);
                    float flow = aT * 3.0 - (uTime * 1.5 * dir);
                    float pulse = smoothstep(0.9, 1.0, sin(flow));
                    col += vec3(1.0) * pulse * 0.6;

                    // Transparência para ver o Oco
                    float distFromCore = abs(xRel) / (uThick * 0.5);
                    vAlpha = 0.3 + 0.7 * smoothstep(0.0, 0.5, distFromCore);
                    
                    if (abs(curlAngle) > 0.1) vAlpha *= 0.8;

                    vColor = col;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTex;
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    vec4 t = texture2D(uTex, gl_PointCoord);
                    if (t.a < 0.1) discard;
                    gl_FragColor = vec4(vColor, vAlpha * t.a);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        const particles = new THREE.Points(geo, material);
        particles.frustumCulled = false;
        scene.add(particles);

        // --- Ativar Bindings ---
        bind('inp-tip', 'uTipSize', 'val-tip');
        bind('inp-thick', 'uThick', 'val-thick');
        bind('inp-outer', 'uOuterR', 'val-outer');
        bind('inp-gap', 'uGap', 'val-gap');
        bind('inp-len', 'uLength', 'val-len');

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = clock.getElapsedTime();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

