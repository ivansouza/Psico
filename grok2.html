<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Shader GLSL - v2</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        // Versão 2: Correções no raymarching, rotação e loops para evitar tela preta
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL não é suportado neste navegador.');
        }

        // Redimensionar canvas para tela cheia
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Vertex Shader (quad fullscreen simples)
        const vsSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // Fragment Shader (seu shader adaptado e corrigido)
        const fsSource = `
            precision mediump float;
            uniform float u_time;
            uniform vec2 u_resolution;
            #define FC gl_FragCoord.xy
            #define r u_resolution
            #define S smoothstep
            #define TAU 6.28318530718

            void main() {
                vec3 o = vec3(0.0);
                float d = 0.0;
                float mm = 1.0;
                float xx = abs(mod(u_time / 4.0, 2.0) - 1.0);
                float aa = (xx < 0.5) ? (-(exp2(12.0 * xx - 6.0) * sin((20.0 * xx - 11.125) * 1.396)) / 2.0) : ((exp2(-12.0 * xx + 6.0) * sin((20.0 * xx - 11.125) * 1.396)) / 2.0 + 1.0);
                vec3 pp, kk;
                float tt = u_time + fract(1e4 * sin(dot(FC, vec2(137.0, -13.0)))) / 60.0;
                float ii = 0.0;
                o *= ii;
                while (ii < 100.0) {
                    ii += 1.0;
                    kk = vec3((FC * 2.0 - r) / r.y * d, d - 9.0);
                    if (abs(kk.x) > 6.0) break;
                    float ll = length(0.2 * kk.xy - vec2(sin(tt) / 9.0, 0.6 + sin(2.0 * tt) / 9.0));
                    if (kk.y < -5.0) {
                        kk.y = -kk.y - 10.0;
                        mm = 0.5;
                    } else {
                        mm = 1.0;
                    }
                    float angle = aa * TAU + kk.y * 0.3 * S(0.2, 0.5, xx) * S(0.7, 0.5, xx);
                    vec4 coss = cos(angle + vec4(0.0, 33.0, 11.0, 0.0));
                    mat2 rotmat = mat2(coss.x, coss.y, coss.z, coss.w);
                    kk.xz *= rotmat;
                    pp = kk * 0.5;
                    float ss = 0.01;
                    for (; ss < 1.0; ss += ss) {
                        vec3 offset = pp.x + 2.0 * tt + pp / ss;
                        vec3 sins = sin(offset);
                        float dot_val = dot(sins, vec3(0.2));
                        pp.y += 0.95 + abs(dot_val) * ss;
                    }
                    ll = mix(sin(length(kk * kk.x)), mix(sin(length(pp)), ll, 0.5 - ll), S(5.5, 6.0, pp.y));
                    pp = abs(kk);
                    float box_max = max(max(pp.x, pp.y), pp.z);
                    float sphere = dot(pp, vec3(0.577)) * mix(0.5, 0.9, aa);
                    float scene = max(sin(length(kk) + ll), max(box_max, sphere) - 3.0);
                    float s = 0.012 + 0.09 * abs(scene - ii / 100.0);
                    d += s;
                    vec4 sinv = sin(vec4(1.0, 2.0, 3.0, 1.0) + ii * 0.5);
                    vec3 glow = sinv.rgb * 1.3 / s;
                    o += max(glow, vec3(-length(kk * kk)));
                }
                o = tanh(o * o / 1e6) * mm;
                gl_FragColor = vec4(o, 1.0);
            }
        `;

        // Compilar shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Erro no shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Erro no programa:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Quad fullscreen
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');

        // Animação
        let startTime = performance.now();
        function render() {
            const currentTime = (performance.now() - startTime) / 1000;
            gl.uniform1f(timeLoc, currentTime);
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>