<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador Shader - Correção HighP</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <!-- Usamos WebGL 2 para melhor performance e recursos -->
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            document.body.innerHTML = '<h1 style="color:white; text-align:center; margin-top:20px">Seu navegador não suporta WebGL 2.</h1>';
            throw new Error("WebGL 2 não suportado");
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- VERTEX SHADER ---
        const vsSource = `#version 300 es
            in vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // --- FRAGMENT SHADER (CORRIGIDO) ---
        const fsSource = `#version 300 es
            // MUDANÇA CRUCIAL: highp é necessário para shaders matemáticos complexos
            precision highp float;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            out vec4 fragColor;

            #define FC gl_FragCoord.xy
            #define r u_resolution
            #define S smoothstep
            #define TAU 6.28318530718

            void main() {
                vec3 o = vec3(0.0);
                float d = 0.0;
                float mm = 1.0;
                
                // Animação temporal
                float xx = abs(mod(u_time / 4.0, 2.0) - 1.0);
                
                // Cálculo de curva de animação (precisa de highp para não travar)
                float aa = (xx < 0.5) ? 
                    (-(exp2(12.0 * xx - 6.0) * sin((20.0 * xx - 11.125) * 1.396)) / 2.0) : 
                    ((exp2(-12.0 * xx + 6.0) * sin((20.0 * xx - 11.125) * 1.396)) / 2.0 + 1.0);
                
                vec3 pp, kk;
                // Perturbação inicial baseada em coordenadas (dither)
                float tt = u_time + fract(1e4 * sin(dot(FC, vec2(137.0, -13.0)))) / 60.0;
                
                float ii = 0.0;
                
                // Loop principal de Raymarching
                // Aumentei o limite de segurança e garanti highp
                while (ii < 100.0) {
                    ii += 1.0;
                    
                    // Projeção da câmera
                    kk = vec3((FC * 2.0 - r) / r.y * d, d - 9.0);
                    
                    // Break de otimização se o raio sair muito para os lados
                    if (abs(kk.x) > 10.0) break; 

                    float ll = length(0.2 * kk.xy - vec2(sin(tt) / 9.0, 0.6 + sin(2.0 * tt) / 9.0));
                    
                    // Espelhamento do chão/teto
                    if (kk.y < -5.0) {
                        kk.y = -kk.y - 10.0;
                        mm = 0.5; // Escurece reflexo
                    } else {
                        mm = 1.0;
                    }
                    
                    // Rotação espacial baseada no tempo (aa)
                    float angle = aa * TAU + kk.y * 0.3 * S(0.2, 0.5, xx) * S(0.7, 0.5, xx);
                    vec4 coss = cos(angle + vec4(0.0, 33.0, 11.0, 0.0));
                    mat2 rotmat = mat2(coss.x, coss.y, coss.z, coss.w);
                    kk.xz *= rotmat;
                    
                    // Fractalização / Repetição espacial
                    pp = kk * 0.5;
                    float ss = 0.01;
                    for (int j = 0; j < 6; j++) { // Loop fixo é mais seguro que float loop
                        if(ss >= 1.0) break;
                        vec3 offset = pp.x + 2.0 * tt + pp / ss;
                        vec3 sins = sin(offset);
                        float dot_val = dot(sins, vec3(0.2));
                        pp.y += 0.95 + abs(dot_val) * ss;
                        ss += ss;
                    }
                    
                    // Mistura de formas (SDF)
                    ll = mix(sin(length(kk * kk.x)), mix(sin(length(pp)), ll, 0.5 - ll), S(5.5, 6.0, pp.y));
                    pp = abs(kk);
                    float box_max = max(max(pp.x, pp.y), pp.z);
                    float sphere = dot(pp, vec3(0.577)) * mix(0.5, 0.9, aa);
                    float scene = max(sin(length(kk) + ll), max(box_max, sphere) - 3.0);
                    
                    // Passo do Raymarch
                    float s = 0.012 + 0.09 * abs(scene - ii / 100.0);
                    d += s;
                    
                    // Acumulação de cor (Glow)
                    vec4 sinv = sin(vec4(1.0, 2.0, 3.0, 1.0) + ii * 0.5);
                    vec3 glow = sinv.rgb * 1.3 / s;
                    
                    // Se o passo for muito pequeno (perto do objeto), adiciona brilho
                    o += max(glow, vec3(-length(kk * kk)));
                    
                    // Se passarmos do plano de fundo
                    if(d > 20.0) break; 
                }
                
                // Tone Mapping
                // Ajustei o divisor de 1e6 para 2e5 para tornar a imagem mais clara se estiver escura
                o = tanh(o * o / 200000.0) * mm;
                
                // Correção Gamma simples para monitores
                o = pow(o, vec3(0.4545));
                
                fragColor = vec4(o, 1.0);
            }
        `;

        // Função auxiliar para compilar
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Geometria
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1, -1,  1,  1,  1
        ]), gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');

        let startTime = performance.now();

        function render() {
            // Tempo em segundos
            const time = (performance.now() - startTime) * 0.001;
            
            gl.uniform1f(timeLoc, time);
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>

