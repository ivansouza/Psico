<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDF Morphing Grid Interativo - Base Ajustada</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        canvas { display: block; }
        .ui-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            z-index: 10;
            width: max-content;
            max-width: 95vw;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
        }
        .instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
            pointer-events: none;
            text-align: center;
            width: 100%;
        }
        .control-group { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        input[type=range] { cursor: pointer; accent-color: #3b82f6; width: 100px; }
        button { 
            background: #3b82f6; 
            border: none; 
            padding: 8px 15px; 
            border-radius: 20px; 
            color: white; 
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        button:hover { background: #2563eb; transform: scale(1.05); }
        label { font-size: 10px; font-weight: bold; letter-spacing: 1px; }
    </style>
</head>
<body>

    <div class="instruction">Duplo clique ou toque para mover o centro</div>

    <div class="ui-panel">
        <div class="control-group">
            <label class="opacity-70">VELOCIDADE</label>
            <input type="range" id="speedRange" min="0" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label class="opacity-70">ALTURA MÁX.</label>
            <input type="range" id="heightRange" min="1" max="20" step="0.5" value="8">
        </div>
        <div class="control-group">
            <label class="opacity-70">CORES</label>
            <button id="colorBtn">Alternar</button>
        </div>
        <div class="control-group">
            <label class="opacity-70">STATUS</label>
            <button id="pauseBtn">Pausar</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Configurações Iniciais de Cores
        let speed = 1.0;
        let isPaused = false;
        let colorIndex = 0;
        const colorPalettes = [
            { inner: new THREE.Color(0xff2d55), outer: new THREE.Color(0x2d55ff) },
            { inner: new THREE.Color(0x00ff88), outer: new THREE.Color(0x5500ff) },
            { inner: new THREE.Color(0xffff00), outer: new THREE.Color(0xff0000) },
            { inner: new THREE.Color(0xffffff), outer: new THREE.Color(0x222222) }
        ];

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(35, 35, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Uniforms para o Shader das Colunas
        const uniforms = {
            time: { value: 0 },
            center: { value: new THREE.Vector2(0, 0) },
            maxHeight: { value: 8.0 },
            innerColor: { value: colorPalettes[0].inner },
            outerColor: { value: colorPalettes[0].outer }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                uniform float time;
                uniform float maxHeight;
                uniform vec2 center;
                varying float vHeight;
                varying float vSdf;
                varying vec3 vNormal;

                float sdHeart(vec2 p) {
                    p.x = abs(p.x);
                    if (p.y + p.x > 1.0)
                        return sqrt(dot(p - vec2(0.25, 0.75), p - vec2(0.25, 0.75))) - 0.3535;
                    return sqrt(min(dot(p - 0.5 * max(p.x + p.y, 0.0), p - 0.5 * max(p.x + p.y, 0.0)), 
                                   dot(p - vec2(0.0, 1.0), p - vec2(0.0, 1.0)))) * sign(p.x - p.y);
                }

                float sdStar5(vec2 p, float r, float rf) {
                    const vec2 k1 = vec2(0.80901699, -0.58778525);
                    const vec2 k2 = vec2(-k1.x, k1.y);
                    p.x = abs(p.x);
                    p -= 2.0 * max(dot(k1, p), 0.0) * k1;
                    p -= 2.0 * max(dot(k2, p), 0.0) * k2;
                    p.x = abs(p.x);
                    p.y -= r;
                    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);
                    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);
                    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);
                }

                void main() {
                    vec4 instancePos = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                    vec2 p = (instancePos.xz - center) / 12.0;
                    p.y *= -1.0; 

                    float dHeart = sdHeart(p + vec2(0.0, 0.3));
                    float dStar = sdStar5(p, 0.8, 0.45);
                    
                    float morph = (sin(time * 1.5) + 1.0) * 0.5;
                    float dist = mix(dHeart, dStar, morph);
                    
                    // Altura mínima das colunas em 8%
                    float h = 0.08 + 0.92 * smoothstep(0.1, -0.1, dist);
                    float finalHeight = h * maxHeight;

                    vec3 pos = position;
                    pos.y *= finalHeight;

                    vHeight = h;
                    vSdf = dist;
                    vNormal = normalMatrix * normal;

                    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 innerColor;
                uniform vec3 outerColor;
                varying float vHeight;
                varying float vSdf;
                varying vec3 vNormal;

                void main() {
                    float mixFactor = smoothstep(-0.2, 0.2, vSdf);
                    vec3 baseColor = mix(innerColor, outerColor, mixFactor);
                    
                    vec3 light = normalize(vec3(1.0, 1.0, 1.0));
                    float d = max(dot(vNormal, light), 0.2);
                    
                    vec3 finalColor = baseColor * d;
                    finalColor += pow(vHeight, 4.0) * 0.3 * innerColor;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        // Configuração da Grade de Colunas
        const gridSize = 44;
        const spacing = 1.1;
        const geometry = new THREE.CylinderGeometry(0.35, 0.35, 1, 12);
        geometry.translate(0, 0.5, 0);

        const instancedMesh = new THREE.InstancedMesh(geometry, material, gridSize * gridSize);
        const dummy = new THREE.Object3D();
        const gridTotalSize = (gridSize - 1) * spacing;
        const offset = gridTotalSize / 2;
        
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                dummy.position.set(x * spacing - offset, 0, z * spacing - offset);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(x * gridSize + z, dummy.matrix);
            }
        }
        scene.add(instancedMesh);

        // --- CUBO DE BASE (PLATAFORMA) ---
        const baseWidth = gridSize * spacing;
        const baseGeom = new THREE.BoxGeometry(baseWidth, 1, baseWidth);
        baseGeom.translate(0, 0.5, 0); 
        
        const baseMaterial = new THREE.MeshPhongMaterial({ 
            color: colorPalettes[0].outer, 
            transparent: true,
            opacity: 0.95,
            shininess: 30
        });
        const basePlate = new THREE.Mesh(baseGeom, baseMaterial);
        scene.add(basePlate);

        // Luzes
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dLight.position.set(10, 30, 15);
        scene.add(dLight);

        // Interação
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const targetCenter = new THREE.Vector2(0, 0);

        const handleInteraction = (clientX, clientY) => {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Plano virtual para intersecção em Y=0
            const planeIntersect = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersectPoint = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(planeIntersect, intersectPoint)) {
                targetCenter.set(intersectPoint.x, intersectPoint.z);
            }
        };

        window.addEventListener('dblclick', (e) => handleInteraction(e.clientX, e.clientY));

        let lastTap = 0;
        window.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0) {
                const touch = e.touches[0];
                handleInteraction(touch.clientX, touch.clientY);
            }
            lastTap = currentTime;
        }, { passive: false });

        // Eventos UI
        document.getElementById('speedRange').addEventListener('input', (e) => speed = parseFloat(e.target.value));
        document.getElementById('heightRange').addEventListener('input', (e) => {
            uniforms.maxHeight.value = parseFloat(e.target.value);
        });
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.innerText = isPaused ? "RETOMAR" : "PAUSAR";
        });
        document.getElementById('colorBtn').addEventListener('click', () => {
            colorIndex = (colorIndex + 1) % colorPalettes.length;
            const palette = colorPalettes[colorIndex];
            uniforms.innerColor.value = palette.inner;
            uniforms.outerColor.value = palette.outer;
            baseMaterial.color.copy(palette.outer);
        });

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;

        // Loop
        let lastTime = 0;
        let accumulatedTime = 0;

        function animate(now) {
            requestAnimationFrame(animate);
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            if (!isPaused) {
                accumulatedTime += delta * speed;
                uniforms.time.value = accumulatedTime;
            }

            // Lógica de Escala: Cubo a 6% da altura máxima (Diferença de 2% para o repouso de 8%)
            basePlate.scale.y = uniforms.maxHeight.value * 0.06;

            uniforms.center.value.x += (targetCenter.x - uniforms.center.value.x) * 0.1;
            uniforms.center.value.y += (targetCenter.y - uniforms.center.value.y) * 0.1;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);
    </script>
</body>
</html>

