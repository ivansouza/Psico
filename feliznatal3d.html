<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Feliz Natal 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #020205, #0a0a1a); /* Gradiente c√©u noturno */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            outline: none;
        }
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        h1 {
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            background: -webkit-linear-gradient(#fff, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        p {
            font-size: 0.8rem;
            margin: 5px 0 0 0;
            opacity: 0.7;
        }
        .instruction {
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 15px;
            display: inline-block;
            margin-top: 10px;
            font-size: 0.75rem;
            color: #ddd;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>FELIZ NATAL</h1>
        <div class="instruction">
            üñ±Ô∏è Arraste para girar &bull; ü§è Pin√ßa/Scroll para Zoom
        </div>
    </div>

    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls para intera√ß√£o 3D (Mouse e Toque) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        /**
         * VARI√ÅVEIS GLOBAIS
         */
        let scene, camera, renderer, controls;
        let material, geometry, points;
        let clock = new THREE.Clock();
        
        // Vento autom√°tico
        const currentWind = new THREE.Vector2(0, 0);

        // Configura√ß√£o da Cena
        const PARTICLE_COUNT = 5000; // Mais part√≠culas para volume 3D
        const RANGE_Y = 200;
        const RANGE_XZ = 200;

        /**
         * GERADOR DE TEXTURA (Mesma l√≥gica robusta anterior)
         */
        function createSnowflakeAtlas() {
            const size = 1024;
            const cells = 4;
            const cellSize = size / cells;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Limpar
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, size, size);
            
            // Estilo
            ctx.strokeStyle = '#ffffff';
            ctx.lineCap = 'round';
            ctx.shadowColor = "rgba(100,200,255,0.9)"; // Brilho azulado
            ctx.shadowBlur = 6;

            function drawBranch(len, depth) {
                if (depth === 0) return;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -len);
                ctx.stroke();
                ctx.translate(0, -len);
                const count = 2;
                for (let i = 0; i < count; i++) {
                    ctx.save();
                    const angle = Math.PI / 3 * (i === 0 ? 1 : -1);
                    ctx.rotate(angle);
                    drawBranch(len * 0.5, depth - 1);
                    ctx.restore();
                }
            }

            for (let y = 0; y < cells; y++) {
                for (let x = 0; x < cells; x++) {
                    const centerX = x * cellSize + cellSize / 2;
                    const centerY = y * cellSize + cellSize / 2;
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    const branches = 6;
                    const len = (cellSize / 2) * 0.65;
                    const thickness = 2 + Math.random() * 3;
                    const complexity = 2 + Math.floor(Math.random() * 2);
                    ctx.lineWidth = thickness;

                    for (let b = 0; b < branches; b++) {
                        ctx.save();
                        ctx.rotate((Math.PI * 2 / branches) * b);
                        drawBranch(len, complexity);
                        // Ornamentos extras
                        if (Math.random() > 0.6) {
                            ctx.beginPath(); 
                            ctx.arc(0, -len*0.6, 2, 0, Math.PI*2); 
                            ctx.fillStyle='white'; 
                            ctx.fill();
                        }
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        /**
         * SHADERS GLSL
         */
        const vertexShader = `
            uniform float uTime;
            uniform float uRangeY;
            uniform float uRangeXZ;
            uniform vec2 uWind;
            uniform float uPixelRatio;

            attribute float aSize;
            attribute float aSpeed;
            attribute float aIndex;
            attribute float aRotationSpeed;
            attribute vec3 aRandomOffset; // Offset aleat√≥rio para cada part√≠cula

            varying float vIndex;
            varying float vRotation;
            varying float vOpacity;

            void main() {
                vIndex = aIndex;
                vec3 pos = position;

                // Anima√ß√£o de Queda (Loop Infinito)
                float fallOffset = uTime * aSpeed;
                
                // Usamos aRandomOffset para desincronizar as part√≠culas
                // Mant√©m a part√≠cula dentro da caixa definida (RangeY)
                pos.y = mod(position.y - fallOffset, uRangeY) - (uRangeY * 0.5);

                // Turbul√™ncia Complexa
                // Combina tempo, posi√ß√£o e offsets para movimento org√¢nico
                float turbulenceX = sin(uTime * 0.5 + pos.y * 0.05 + aRandomOffset.x) * 2.0;
                float turbulenceZ = cos(uTime * 0.3 + pos.y * 0.05 + aRandomOffset.z) * 2.0;

                // Aplicar Vento Global
                pos.x += uWind.x * (10.0 - pos.y * 0.05) + turbulenceX;
                pos.z += uWind.y * (10.0 - pos.y * 0.05) + turbulenceZ;

                // Loop Infinito nas laterais (Tiling do mundo)
                pos.x = mod(pos.x + uRangeXZ * 0.5, uRangeXZ) - uRangeXZ * 0.5;
                pos.z = mod(pos.z + uRangeXZ * 0.5, uRangeXZ) - uRangeXZ * 0.5;

                // Calcular Posi√ß√£o final na Tela
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Tamanho com atenua√ß√£o de dist√¢ncia
                // Part√≠culas longe ficam menores
                gl_PointSize = aSize * uPixelRatio * (60.0 / -mvPosition.z);

                // Rota√ß√£o enviada para o fragment
                vRotation = uTime * aRotationSpeed + aRandomOffset.y;
                
                // Fade nas bordas verticais da caixa de simula√ß√£o
                float distY = abs(pos.y) / (uRangeY * 0.48);
                vOpacity = 1.0 - smoothstep(0.8, 1.0, distY);
                
                // Fade se estiver muito perto da c√¢mera (evita sustos)
                float distCam = length(mvPosition.xyz);
                vOpacity *= smoothstep(2.0, 10.0, distCam);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            varying float vIndex;
            varying float vRotation;
            varying float vOpacity;

            void main() {
                // Rota√ß√£o da textura 2D
                vec2 uv = gl_PointCoord;
                vec2 centered = uv - 0.5;
                float s = sin(vRotation);
                float c = cos(vRotation);
                mat2 rot = mat2(c, -s, s, c);
                centered = rot * centered;
                uv = centered + 0.5;

                // Sele√ß√£o no Atlas 4x4
                float atlasCells = 4.0;
                float col = mod(vIndex, atlasCells);
                float row = floor(vIndex / atlasCells);
                vec2 atlasUV = (uv / atlasCells) + vec2(col / atlasCells, 1.0 - (row + 1.0) / atlasCells);

                vec4 texColor = texture2D(uTexture, atlasUV);

                // Cor levemente azulada
                gl_FragColor = texColor * vec4(0.95, 0.98, 1.0, vOpacity);
                
                if(gl_FragColor.a < 0.01) discard;
            }
        `;

        function init() {
            // Setup B√°sico
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.008); // Nevoeiro mais denso para imers√£o

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 20, 60); // Posi√ß√£o inicial levemente elevada

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // CONTROLES DE √ìRBITA
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Movimento suave (in√©rcia)
            controls.dampingFactor = 0.05;
            controls.enablePan = false; // Manter foco no centro da tempestade
            controls.minDistance = 10;
            controls.maxDistance = 150;
            controls.autoRotate = false; // Deixar o usu√°rio controlar

            // PARTICULAS
            geometry = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            const speeds = [];
            const indices = [];
            const rotationSpeeds = [];
            const randomOffsets = [];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions.push(
                    (Math.random() - 0.5) * RANGE_XZ,
                    (Math.random() - 0.5) * RANGE_Y,
                    (Math.random() - 0.5) * RANGE_XZ
                );
                sizes.push(15.0 + Math.random() * 25.0);
                speeds.push(3.0 + Math.random() * 6.0);
                indices.push(Math.floor(Math.random() * 16));
                rotationSpeeds.push((Math.random() - 0.5) * 3.0);
                // 3 valores aleat√≥rios para usar no shader
                randomOffsets.push(Math.random() * 100, Math.random() * 100, Math.random() * 100);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aSpeed', new THREE.Float32BufferAttribute(speeds, 1));
            geometry.setAttribute('aIndex', new THREE.Float32BufferAttribute(indices, 1));
            geometry.setAttribute('aRotationSpeed', new THREE.Float32BufferAttribute(rotationSpeeds, 1));
            geometry.setAttribute('aRandomOffset', new THREE.Float32BufferAttribute(randomOffsets, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uRangeY: { value: RANGE_Y },
                    uRangeXZ: { value: RANGE_XZ },
                    uTexture: { value: createSnowflakeAtlas() },
                    uWind: { value: new THREE.Vector2(0, 0) },
                    uPixelRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        function animate() {
            requestAnimationFrame(animate);

            const elapsed = clock.getElapsedTime();
            const delta = clock.getDelta();

            // Atualiza controles (necess√°rio para o efeito de in√©rcia/damping)
            controls.update();

            // Vento Autom√°tico Vari√°vel
            // Cria um padr√£o de vento que muda de dire√ß√£o suavemente ao longo do tempo
            const windTime = elapsed * 0.2;
            const targetWindX = Math.sin(windTime) * 3.0 + Math.cos(windTime * 2.5) * 1.0;
            const targetWindZ = Math.cos(windTime * 0.8) * 3.0;
            
            // Interpola√ß√£o suave do vento
            currentWind.x += (targetWindX - currentWind.x) * 0.02;
            currentWind.y += (targetWindZ - currentWind.y) * 0.02;

            material.uniforms.uTime.value = elapsed;
            material.uniforms.uWind.value = currentWind;

            // Render
            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>