<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fluxo de Marangoni - Dinâmica de Cores</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Inter', sans-serif; }
        canvas { display: block; touch-action: none; }
        
        .glass-panel {
            background: rgba(10, 10, 20, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
        }

        .panel-hidden {
            transform: translateX(-120%);
            opacity: 0;
            pointer-events: none;
        }

        .gear-btn {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Estilo específico para o slider de cores */
        #hueSlider::-webkit-slider-runnable-track {
            background: linear-gradient(to right, #ff0000, #ff8000, #ffff00, #00ff00, #00ffff, #0000ff, #8000ff, #ff00ff, #ff0000);
            border-radius: 2px;
            height: 6px;
        }

        #toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(99, 102, 241, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
        }
        #toast.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>

    <!-- Botão de Definições -->
    <button id="toggleUI" class="gear-btn fixed top-6 left-6 z-50 p-4 rounded-full text-white border border-white/10 shadow-xl active:scale-95">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
    </button>

    <div id="toast">Estado Guardado!</div>

    <!-- Painel de UI -->
    <div id="uiPanel" class="glass-panel panel-hidden fixed top-24 left-6 z-40 p-6 rounded-3xl w-72 text-white overflow-y-auto max-h-[80vh]">
        <h1 class="text-lg font-bold mb-1">Fluido 3D</h1>
        <p class="text-[10px] text-indigo-400 mb-6 uppercase tracking-widest font-bold">Personalização Visual</p>
        
        <div class="space-y-6">
            <!-- Slider de Cores -->
            <div class="control-group">
                <div class="flex justify-between mb-2">
                    <label class="text-xs font-medium opacity-70">Espectro de Cor</label>
                    <span id="hueVal" class="text-xs font-mono">0°</span>
                </div>
                <input type="range" id="hueSlider" min="0" max="1" step="0.01" value="0" class="w-full">
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-2">
                    <label class="text-xs font-medium opacity-70">Intensidade</label>
                    <span id="intensityVal" class="text-xs font-mono">1.30</span>
                </div>
                <input type="range" id="intensity" min="0.1" max="10.0" step="0.1" value="1.3" class="w-full">
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-2">
                    <label class="text-xs font-medium opacity-70">Número de Gotas</label>
                    <span id="dropCountVal" class="text-xs font-mono">13</span>
                </div>
                <input type="range" id="dropCount" min="1" max="16" step="1" value="13" class="w-full">
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-2">
                    <label class="text-xs font-medium opacity-70">Velocidade</label>
                    <span id="dropSpeedVal" class="text-xs font-mono">1.12</span>
                </div>
                <input type="range" id="dropSpeed" min="0.02" max="3.0" step="0.02" value="1.12" class="w-full">
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-2">
                    <label class="text-xs font-medium opacity-70">Viscosidade (Fricção)</label>
                    <span id="viscosityVal" class="text-xs font-mono">0.15</span>
                </div>
                <input type="range" id="viscosity" min="0.01" max="0.5" step="0.01" value="0.15" class="w-full">
            </div>
        </div>

        <div class="mt-8 pt-6 border-t border-white/10 space-y-3">
            <button id="saveStorage" class="w-full py-2.5 bg-indigo-600 hover:bg-indigo-500 rounded-xl text-xs font-bold transition-all flex items-center justify-center gap-2">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                Guardar Estado
            </button>
            <button id="copyJSON" class="w-full py-2.5 bg-white/10 hover:bg-white/20 rounded-xl text-xs font-bold transition-all flex items-center justify-center gap-2">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>
                Copiar JSON
            </button>
        </div>
    </div>

    <!-- Vertex Shader -->
    <script id="vertexShader" type="x-shader/x-vertex">
        #define MAX_IMPACTS 16
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying float vElevation;

        uniform float uTime;
        uniform float uFrequency;
        uniform float uIntensity;
        uniform float uWaveSpeed;
        uniform vec2 uMouse;
        uniform float uMouseDown;
        
        uniform vec2 uImpactPos[MAX_IMPACTS];
        uniform float uImpactStrength[MAX_IMPACTS];
        uniform float uImpactTime[MAX_IMPACTS];

        vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
        float snoise(vec2 v){
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m * m*m;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        void main() {
            vUv = uv;
            float noise = snoise(uv * uFrequency * 0.2 + uTime * 0.05);
            float elevation = noise * 0.05 * uIntensity;

            if(uMouseDown > 0.5) {
                elevation += exp(-distance(uv, uMouse) * 15.0) * 0.4;
            }
            
            for(int i = 0; i < MAX_IMPACTS; i++) {
                if(uImpactStrength[i] > 0.01) {
                    float dist = distance(uv, uImpactPos[i]);
                    float timeSince = uTime - uImpactTime[i];
                    
                    if(timeSince > 0.0) {
                        float wavePos = dist * 70.0 - timeSince * (25.0 * uWaveSpeed);
                        float wave = sin(wavePos);
                        float waveFront = smoothstep(0.1, -0.1, dist - timeSince * (uWaveSpeed * 0.4));
                        float spatialDecay = exp(-dist * 5.0);
                        float temporalDecay = exp(-timeSince * (1.2 * clamp(uWaveSpeed, 0.1, 3.0)));
                        elevation += wave * waveFront * spatialDecay * temporalDecay * 0.6 * uImpactStrength[i];
                        elevation -= exp(-dist * 40.0) * temporalDecay * 0.5 * uImpactStrength[i];
                    }
                }
            }

            vElevation = elevation;
            vec3 pos = position;
            pos.z += elevation;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            vViewPosition = -mvPosition.xyz;
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        #define MAX_IMPACTS 16
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying float vElevation;
        
        uniform float uTime;
        uniform float uHue;
        uniform vec2 uMouse;
        uniform vec2 uImpactPos[MAX_IMPACTS];
        uniform float uImpactStrength[MAX_IMPACTS];
        uniform float uImpactTime[MAX_IMPACTS];

        // Função para converter Hue para RGB
        vec3 hueToRgb(float h) {
            float r = abs(h * 6.0 - 3.0) - 1.0;
            float g = 2.0 - abs(h * 6.0 - 2.0);
            float b = 2.0 - abs(h * 6.0 - 4.0);
            return clamp(vec3(r, g, b), 0.0, 1.0);
        }

        vec3 getReflection(vec3 normal, vec3 viewDir, float hue) {
            vec3 r = reflect(-viewDir, normal);
            float m = 2.828 * sqrt( r.z+1.0 );
            vec2 envUv = r.xy / m + 0.5;
            float l = pow(max(0.0, sin(envUv.x * 12.0) * cos(envUv.y * 10.0)), 15.0);
            
            vec3 baseReflect = hueToRgb(hue) * 0.2;
            return mix(baseReflect, vec3(1.0), l);
        }

        void main() {
            // Cores base extraídas da matiz
            vec3 tint = hueToRgb(uHue);
            vec3 baseCol = tint * 0.15;
            vec3 peakCol = mix(tint, vec3(1.0), 0.5);
            
            vec3 normal = normalize(vNormal);
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 4.5);
            vec3 reflectCol = getReflection(normal, viewDir, uHue);
            
            vec3 color = mix(baseCol, peakCol, clamp(vElevation * 5.0, 0.0, 1.0));
            
            float glow = 0.0;
            for(int i = 0; i < MAX_IMPACTS; i++) {
                if(uImpactStrength[i] > 0.0) {
                    float t = uTime - uImpactTime[i];
                    glow += exp(-distance(vUv, uImpactPos[i]) * 40.0) * uImpactStrength[i] * exp(-t * 6.0);
                }
            }
            
            vec3 final = color + reflectCol * (fresnel + 0.3) + glow * tint;
            float spec = pow(max(dot(normal, vec3(0,0,1)), 0.0), 128.0);
            gl_FragColor = vec4(final + spec * 0.5, 1.0);
        }
    </script>

    <script>
        const MAX_DROPS = 16;
        const STORAGE_KEY = 'marangoni_sim_state_v2';
        let scene, camera, renderer, material, mesh, raycaster;
        let drops = [];
        
        // PARÂMETROS INICIAIS (CONFORME PEDIDO)
        let targetIntensity = 1.3;
        let targetDropCount = 13;
        let targetDropSpeed = 1.12; 
        let viscosity = 0.15;
        let targetHue = 0.65; // Padrão azulado

        // CÂMARA (CONFORME PEDIDO)
        let rotX = -0.6047821044921877;
        let rotY = 0.5751355895996094;
        let targetRotX = -0.6047821044921877;
        let targetRotY = 0.5751355895996094;
        let cameraDist = 7.386162167143095;
        let targetDist = 7.386162167143095;
        
        let lastTouchX = 0, lastTouchY = 0, lastPinchDist = 0;
        let isOrbiting = false;
        const mouseState = { screen: new THREE.Vector2(-1, -1), uv: new THREE.Vector2(0.5, 0.5), down: 0 };

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerText = msg; toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        function createDrop() {
            const dropGeo = new THREE.SphereBufferGeometry(0.045, 12, 12);
            const dropMat = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, shininess: 100 });
            const dropMesh = new THREE.Mesh(dropGeo, dropMat);
            scene.add(dropMesh);
            return { 
                mesh: dropMesh, y: 3 + Math.random() * 4, velocity: 0, 
                uv: new THREE.Vector2(0.1 + Math.random() * 0.8, 0.1 + Math.random() * 0.8), 
                impact: 0, startTime: 0, active: false 
            };
        }

        function saveToLocalStorage() {
            const state = { 
                hue: targetHue,
                intensity: targetIntensity, 
                dropCount: targetDropCount, 
                dropSpeed: targetDropSpeed, 
                viscosity: viscosity, 
                rotX: targetRotX, rotY: targetRotY, dist: targetDist 
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            showToast("Estado Guardado!");
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const s = JSON.parse(saved);
                targetHue = s.hue ?? 0.65;
                targetIntensity = s.intensity; targetDropCount = s.dropCount;
                targetDropSpeed = s.dropSpeed || 1.12; viscosity = s.viscosity;
                targetRotX = s.rotX; targetRotY = s.rotY; targetDist = s.dist;
                
                // Sincronizar UI
                document.getElementById('hueSlider').value = targetHue;
                document.getElementById('hueVal').innerText = Math.round(targetHue * 360) + "°";
                document.getElementById('intensity').value = targetIntensity;
                document.getElementById('intensityVal').innerText = targetIntensity.toFixed(2);
                document.getElementById('dropCount').value = targetDropCount;
                document.getElementById('dropCountVal').innerText = targetDropCount;
                document.getElementById('dropSpeed').value = targetDropSpeed;
                document.getElementById('dropSpeedVal').innerText = targetDropSpeed.toFixed(2);
                document.getElementById('viscosity').value = viscosity;
                document.getElementById('viscosityVal').innerText = viscosity.toFixed(2);
                
                rotX = targetRotX; rotY = targetRotY; cameraDist = targetDist;
            }
        }

        function copyStateAsJSON() {
            const json = JSON.stringify({ 
                hue: targetHue,
                intensity: targetIntensity, 
                dropCount: targetDropCount, 
                dropSpeed: targetDropSpeed, 
                viscosity: viscosity, 
                camera: { rotX: targetRotX, rotY: targetRotY, dist: targetDist }, 
                timestamp: new Date().toISOString() 
            }, null, 2);
            const ta = document.createElement("textarea"); ta.value = json; document.body.appendChild(ta); ta.select();
            try { document.execCommand('copy'); showToast("JSON Copiado!"); } catch (e) { showToast("Erro."); }
            document.body.removeChild(ta);
        }

        function init() {
            loadFromLocalStorage();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster();
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.PlaneBufferGeometry(4, 4, 256, 256);
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 }, uFrequency: { value: 6.0 }, uIntensity: { value: targetIntensity },
                    uHue: { value: targetHue },
                    uWaveSpeed: { value: targetDropSpeed }, uMouse: { value: new THREE.Vector2(0.5, 0.5) }, uMouseDown: { value: 0.0 },
                    uImpactPos: { value: Array(MAX_DROPS).fill(new THREE.Vector2()) },
                    uImpactStrength: { value: Array(MAX_DROPS).fill(0.0) },
                    uImpactTime: { value: Array(MAX_DROPS).fill(0.0) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                side: THREE.DoubleSide
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            scene.add(mesh);

            for(let i = 0; i < MAX_DROPS; i++) drops.push(createDrop());

            const light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(5, 10, 5); scene.add(light);
            scene.add(new THREE.AmbientLight(0x202020));

            setupEvents();
            animate();
        }

        function setupEvents() {
            document.getElementById('toggleUI').onclick = () => document.getElementById('uiPanel').classList.toggle('panel-hidden');
            document.getElementById('saveStorage').onclick = saveToLocalStorage;
            document.getElementById('copyJSON').onclick = copyStateAsJSON;

            const link = (id, cb) => document.getElementById(id).oninput = (e) => {
                const v = parseFloat(e.target.value); cb(v);
                const display = document.getElementById(id + 'Val');
                if(display) display.innerText = (id === 'hueSlider') ? Math.round(v * 360) + "°" : v.toFixed(2);
            };
            link('hueSlider', v => { targetHue = v; material.uniforms.uHue.value = v; });
            link('intensity', v => targetIntensity = v);
            link('dropCount', v => targetDropCount = v);
            link('dropSpeed', v => { targetDropSpeed = v; material.uniforms.uWaveSpeed.value = v; });
            link('viscosity', v => viscosity = v);

            const getDist = (t1, t2) => Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);

            window.addEventListener('touchstart', (e) => {
                if (e.target.closest('.glass-panel') || e.target.closest('button')) return;
                mouseState.down = 1;
                if (e.touches.length === 1) { isOrbiting = true; lastTouchX = e.touches[0].pageX; lastTouchY = e.touches[0].pageY; } 
                else if (e.touches.length === 2) { isOrbiting = false; lastPinchDist = getDist(e.touches[0], e.touches[1]); }
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                if (e.target.closest('.glass-panel')) return;
                const tx = e.touches[0].clientX, ty = e.touches[0].clientY;
                mouseState.screen.set((tx / window.innerWidth) * 2 - 1, -(ty / window.innerHeight) * 2 + 1);
                if (e.touches.length === 1 && isOrbiting) {
                    targetRotY += (e.touches[0].pageX - lastTouchX) * 0.01;
                    targetRotX += (e.touches[0].pageY - lastTouchY) * 0.01;
                    targetRotX = Math.max(-1.5, Math.min(-0.1, targetRotX));
                    lastTouchX = e.touches[0].pageX; lastTouchY = e.touches[0].pageY;
                } else if (e.touches.length === 2) {
                    const dist = getDist(e.touches[0], e.touches[1]);
                    targetDist = Math.max(1.5, Math.min(15.0, targetDist + (lastPinchDist - dist) * 0.02));
                    lastPinchDist = dist;
                }
            }, { passive: false });

            window.addEventListener('touchend', () => { mouseState.down = 0; isOrbiting = false; });

            window.addEventListener('mousedown', (e) => {
                if (e.target.closest('.glass-panel') || e.target.closest('button')) return;
                mouseState.down = 1; isOrbiting = true; lastTouchX = e.clientX; lastTouchY = e.clientY;
            });
            window.addEventListener('mousemove', (e) => {
                mouseState.screen.set((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
                if (isOrbiting) {
                    targetRotY += (e.clientX - lastTouchX) * 0.007;
                    targetRotX += (e.clientY - lastTouchY) * 0.007;
                    targetRotX = Math.max(-1.5, Math.min(-0.1, targetRotX));
                    lastTouchX = e.clientX; lastTouchY = e.clientY;
                }
            });
            window.addEventListener('mouseup', () => { mouseState.down = 0; isOrbiting = false; });
            window.addEventListener('wheel', (e) => { targetDist = Math.max(1.5, Math.min(15.0, targetDist + e.deltaY * 0.002)); }, { passive: true });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const impactPos = []; const impactStr = []; const impactT = [];

            drops.forEach((d, i) => {
                if (i < targetDropCount) {
                    d.velocity -= 0.005 * targetDropSpeed; 
                    d.y += d.velocity;
                    if (d.y <= 0 && !d.active) {
                        d.y = 0; d.impact = 1.0; d.startTime = time; d.active = true;
                        setTimeout(() => { 
                            d.y = 3 + Math.random()*4; d.velocity = 0; 
                            d.uv.set(0.1 + Math.random() * 0.8, 0.1 + Math.random() * 0.8);
                            d.active = false; 
                        }, (800 + Math.random()*800) / Math.max(targetDropSpeed, 0.1));
                    }
                    d.impact *= 0.96;
                    d.mesh.position.set((d.uv.x-0.5)*4, d.y + 0.05, (d.uv.y-0.5)*4);
                    d.mesh.visible = d.y > 0;
                    impactPos.push(d.uv); impactStr.push(d.impact); impactT.push(d.startTime);
                } else {
                    d.mesh.visible = false; impactPos.push(new THREE.Vector2()); impactStr.push(0); impactT.push(0);
                }
            });

            material.uniforms.uTime.value = time;
            material.uniforms.uImpactPos.value = impactPos;
            material.uniforms.uImpactStrength.value = impactStr;
            material.uniforms.uImpactTime.value = impactT;
            material.uniforms.uIntensity.value += (targetIntensity - material.uniforms.uIntensity.value) * 0.05;
            material.uniforms.uHue.value = targetHue;
            
            const orbitEase = 1.0 - Math.min(viscosity, 0.99);
            rotX += (targetRotX - rotX) * orbitEase;
            rotY += (targetRotY - rotY) * orbitEase;
            cameraDist += (targetDist - cameraDist) * orbitEase;
            
            camera.position.set(cameraDist * Math.sin(rotY) * Math.cos(rotX), -cameraDist * Math.sin(rotX), cameraDist * Math.cos(rotY) * Math.cos(rotX));
            camera.lookAt(0, 0, 0);

            raycaster.setFromCamera(mouseState.screen, camera);
            const hits = raycaster.intersectObject(mesh);
            if (hits.length > 0) mouseState.uv.copy(hits[0].uv);
            material.uniforms.uMouse.value.copy(mouseState.uv);
            material.uniforms.uMouseDown.value = mouseState.down;

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>

