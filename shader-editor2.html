<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Editor GLSL Mobile - Fix de Seleção</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-glsl.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Reset e Base */
        body, html {
            margin: 0; padding: 0; height: 100%; overflow: hidden;
            background: #0a0a0a; color: #eee;
            font-family: system-ui, -apple-system, sans-serif;
        }

        .app-container {
            display: grid;
            grid-template-rows: 40% 60%;
            height: 100vh;
            transition: grid-template-rows 0.3s ease;
        }

        @media (min-width: 768px) {
            .app-container { grid-template-rows: 1fr; grid-template-columns: 1fr 1fr; }
        }

        /* Modo Tela Cheia Visual */
        body.is-fullscreen .app-container { grid-template-rows: 100% 0%; }
        body.is-fullscreen #editor-container { display: none !important; }

        /* Estilos do Canvas */
        #canvas-container {
            position: relative; background: #000;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        canvas { width: 100%; height: 100%; object-fit: contain; touch-action: none; }

        /* Estilos do Editor - CORREÇÃO DO DESLOCAMENTO */
        #editor-container {
            position: relative; background: #1a1a1a;
            display: flex; flex-direction: column; overflow: hidden;
            border-top: 1px solid #333;
        }

        #code-area {
            position: relative; flex-grow: 1; overflow: hidden;
        }

        /* Fonte idêntica para ambos é CRUCIAL */
        #editing, #highlighting {
            margin: 0;
            padding: 20px;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: none;
            outline: none;
            /* Força fonte monoespaçada e métricas idênticas */
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace !important;
            font-size: 14px !important;
            line-height: 20px !important; /* Valor fixo em pixels para evitar shift */
            tab-size: 4;
            white-space: pre;
            overflow-wrap: normal;
            box-sizing: border-box;
            letter-spacing: normal;
            word-spacing: normal;
        }

        #editing {
            z-index: 1;
            color: transparent;
            background: transparent;
            caret-color: #3b82f6;
            resize: none;
            -webkit-text-fill-color: transparent;
            overflow: auto;
        }

        #highlighting {
            z-index: 0;
            pointer-events: none;
            overflow: hidden; /* O scroll é controlado pelo textarea */
            background: #1a1a1a;
        }

        code[class*="language-"], pre[class*="language-"] {
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
        }

        /* Log de Erros */
        #error-log {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(127, 29, 29, 0.95); color: #fecaca;
            padding: 12px; font-size: 12px; max-height: 30%;
            overflow-y: auto; display: none; z-index: 50;
            font-family: monospace; border-top: 2px solid #ef4444;
        }

        /* Botões */
        .ui-overlay {
            position: absolute; top: 12px; right: 12px;
            display: flex; flex-direction: column; gap: 8px; z-index: 100;
        }

        .btn {
            background: rgba(20, 20, 20, 0.8); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1); color: #fff;
            padding: 8px 12px; border-radius: 6px; font-size: 12px;
            cursor: pointer; transition: 0.2s;
        }
        .btn:hover { background: #3b82f6; border-color: #3b82f6; }

        .status-badge {
            position: absolute; bottom: 12px; left: 12px;
            padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;
        }
    </style>
</head>
<body id="body-root">

<div class="app-container" id="app-root">
    <!-- Visualização -->
    <div id="canvas-container">
        <canvas id="gl-canvas"></canvas>
        <div class="ui-overlay">
            <button class="btn" onclick="togglePlay()" id="btn-play">Pausar</button>
            <button class="btn" onclick="handleFullscreen()" id="btn-fs">Ver Resultado</button>
            <button class="btn" onclick="resetTime()">Reset</button>
            <button class="btn" onclick="copyCode()">Copiar</button>
        </div>
        <div id="status" class="status-badge bg-blue-600 text-white">Pronto</div>
    </div>

    <!-- Editor -->
    <div id="editor-container">
        <div class="flex items-center justify-between px-4 py-2 bg-[#121212] border-b border-white/10">
            <span class="text-[10px] text-zinc-500 font-mono font-bold tracking-widest">GLSL EDITOR</span>
            <span id="cursor-pos" class="text-[10px] text-zinc-500 font-mono">Linha 1, Col 1</span>
        </div>
        
        <div id="code-area">
            <!-- Camada de Destaque -->
            <pre id="highlighting" aria-hidden="true"><code class="language-glsl" id="highlighting-content"></code></pre>
            <!-- Camada de Interação -->
            <textarea id="editing" spellcheck="false" 
                oninput="updateEditor(this.value); syncScroll(this);" 
                onscroll="syncScroll(this);" 
                onkeydown="handleKey(event)"
                onmousedown="updateCursorInfo()"
                onkeyup="updateCursorInfo()"></textarea>
        </div>
        <div id="error-log"></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gl-canvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    const editing = document.getElementById('editing');
    const highlighting = document.getElementById('highlighting');
    const highlightingContent = document.getElementById('highlighting-content');
    const errorLog = document.getElementById('error-log');
    const statusBadge = document.getElementById('status');
    const cursorPos = document.getElementById('cursor-pos');
    const btnPlay = document.getElementById('btn-play');
    const btnFs = document.getElementById('btn-fs');
    const canvasContainer = document.getElementById('canvas-container');
    const bodyRoot = document.getElementById('body-root');

    let program;
    let positionBuffer;
    let startTime = Date.now();
    let pausedTime = 0;
    let isPaused = false;
    let mouseX = 0, mouseY = 0;

    // Snippet inicial
    const initialCode = `vec2 p=abs(FC.xy/r-.5);
o=p.xyxy/p.yxyx/vec4(3,6,9,1);
o=tanh(o+.1*length(o));`;

    // Wrapper para suportar snippets sem main() e WebGL 2/1
    function wrapShader(code) {
        if (code.includes('void main')) return code;
        const isWebGL2 = gl instanceof WebGL2RenderingContext;
        
        const header = isWebGL2 ? `#version 300 es
            precision highp float;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;
            out vec4 outColor;
            #define FC gl_FragCoord
            #define r u_resolution
            #define t u_time
            #define m u_mouse
            #define o outColor
        ` : `
            precision highp float;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;
            #define FC gl_FragCoord
            #define r u_resolution
            #define t u_time
            #define m u_mouse
            #define o gl_FragColor
            vec4 tanh(vec4 x) { vec4 e=exp(2.0*x); return (e-1.0)/(e+1.0); }
        `;

        return `${header}\nvoid main() {\n${code}\n}`;
    }

    function initGL(userInput) {
        try {
            const isWebGL2 = gl instanceof WebGL2RenderingContext;
            const fragmentSource = wrapShader(userInput);
            const vertexSource = isWebGL2 ? 
                `#version 300 es\nin vec4 position; void main() { gl_Position = position; }` : 
                `attribute vec4 position; void main() { gl_Position = position; }`;
            
            const vs = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

            const newProgram = gl.createProgram();
            gl.attachShader(newProgram, vs);
            gl.attachShader(newProgram, fs);
            gl.linkProgram(newProgram);

            if (!gl.getProgramParameter(newProgram, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(newProgram));
            }

            program = newProgram;
            errorLog.style.display = 'none';
            statusBadge.textContent = 'Ativo';
            statusBadge.className = 'status-badge bg-green-600 text-white';

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        } catch (e) {
            showError(e.message);
        }
    }

    function createShader(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(s);
            gl.deleteShader(s);
            throw new Error(info);
        }
        return s;
    }

    function showError(msg) {
        errorLog.textContent = msg;
        errorLog.style.display = 'block';
        statusBadge.textContent = 'Erro';
        statusBadge.className = 'status-badge bg-red-600 text-white';
    }

    function render() {
        if (!program || isPaused) { requestAnimationFrame(render); return; }
        resizeCanvas();
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);

        const posLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(gl.getUniformLocation(program, "u_resolution"), canvas.width, canvas.height);
        gl.uniform1f(gl.getUniformLocation(program, "u_time"), (Date.now() - startTime) / 1000.0);
        gl.uniform2f(gl.getUniformLocation(program, "u_mouse"), mouseX, mouseY);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    function resizeCanvas() {
        const w = canvasContainer.clientWidth;
        const h = canvasContainer.clientHeight;
        if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
    }

    function updateEditor(val) {
        // Prism ignora a última quebra de linha se não adicionarmos um espaço
        highlightingContent.textContent = val + (val.endsWith("\n") ? " " : "");
        Prism.highlightElement(highlightingContent);
        initGL(val);
    }

    function syncScroll(el) {
        highlighting.scrollTop = el.scrollTop;
        highlighting.scrollLeft = el.scrollLeft;
    }

    function handleKey(e) {
        if (e.key === 'Tab') {
            e.preventDefault();
            const start = editing.selectionStart;
            const end = editing.selectionEnd;
            editing.value = editing.value.substring(0, start) + "    " + editing.value.substring(end);
            editing.selectionStart = editing.selectionEnd = start + 4;
            updateEditor(editing.value);
        }
    }

    function updateCursorInfo() {
        // Pequeno delay para garantir que a seleção foi processada
        setTimeout(() => {
            const textBefore = editing.value.substring(0, editing.selectionStart);
            const lines = textBefore.split('\n');
            cursorPos.textContent = `Linha ${lines.length}, Col ${lines[lines.length - 1].length + 1}`;
        }, 10);
    }

    function togglePlay() {
        isPaused = !isPaused;
        btnPlay.textContent = isPaused ? 'Retomar' : 'Pausar';
        if (!isPaused) startTime = Date.now() - pausedTime;
        else pausedTime = Date.now() - startTime;
    }

    function handleFullscreen() {
        const isPseudo = bodyRoot.classList.contains('is-fullscreen');
        if (document.fullscreenElement || isPseudo) {
            if (document.fullscreenElement) document.exitFullscreen();
            else { bodyRoot.classList.remove('is-fullscreen'); btnFs.textContent = 'Ver Resultado'; }
        } else {
            canvasContainer.requestFullscreen().catch(() => {
                bodyRoot.classList.add('is-fullscreen');
                btnFs.textContent = 'Voltar ao Código';
            });
        }
        setTimeout(resizeCanvas, 100);
    }

    // Interação de Mouse/Touch
    const handleInput = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouseX = clientX - rect.left;
        mouseY = rect.height - (clientY - rect.top);
    };

    canvas.addEventListener('mousemove', handleInput);
    canvas.addEventListener('touchmove', (e) => { handleInput(e); e.preventDefault(); }, { passive: false });

    function resetTime() { startTime = Date.now(); pausedTime = 0; }
    function copyCode() {
        editing.select();
        document.execCommand('copy');
        const old = btnFs.textContent;
        const target = event.target;
        target.textContent = 'Copiado!';
        setTimeout(() => target.textContent = 'Copiar', 2000);
    }

    document.addEventListener('fullscreenchange', () => {
        const isFs = !!document.fullscreenElement;
        bodyRoot.classList.toggle('is-fullscreen', isFs);
        btnFs.textContent = isFs ? 'Sair' : 'Ver Resultado';
        setTimeout(resizeCanvas, 100);
    });

    window.onload = () => {
        editing.value = initialCode;
        updateEditor(initialCode);
        render();
    };
</script>
</body>
</html>
