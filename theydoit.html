<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Film Strip - Estabilidade Máxima</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Arial', sans-serif;
            color: white; 
        }
        canvas { display: block; }
        
        /* Estilos da Tela de Configuração (Compacta e Arrastável) */
        #control-panel {
            position: fixed;
            top: 50%; /* Posição inicial: Centro da tela */
            left: 50%;
            width: 260px;
            max-width: 90%; 
            max-height: 70vh; 
            
            background: rgba(10, 10, 20, 0.98); 
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.9);
            padding: 10px;
            
            /* Estado inicial: Oculto e movido para fora da tela */
            opacity: 0; 
            transform: translate(-50%, calc(100% + 20px)); 
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        /* Estado aberto */
        #control-panel.open {
            opacity: 1;
            transform: translate(-50%, -50%); /* Centralizado na tela */
            pointer-events: auto; 
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
        }

        /* Área de Arraste */
        #drag-handle {
            cursor: move;
            height: 25px;
            background-color: rgba(0, 255, 255, 0.1);
            margin: -10px -10px 10px -10px;
            padding: 5px 10px;
            border-radius: 8px 8px 0 0;
            text-align: center;
            font-size: 0.8em;
            font-weight: bold;
            color: #00ffff;
        }

        /* Botão de Toggle (Engrenagem no canto inferior direito) */
        #toggle-button {
            position: fixed; 
            bottom: 20px;
            right: 20px;
            
            width: 40px;
            height: 40px;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid #00FFFF;
            border-radius: 50%; 
            color: #00FFFF;
            cursor: pointer;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.5);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 1001; 
            animation: spin 8s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Botão de Fechar no Painel */
        #close-button {
            position: absolute; top: 5px; right: 5px;
            background: none; border: none; color: #fff; font-size: 1em; cursor: pointer;
            z-index: 1002;
            padding: 5px;
        }
        
        /* Estilos dos Controles MÍNIMOS */
        .control-group {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px; 
        }

        .control-group h2 {
            font-size: 1em;
            padding-bottom: 5px;
        }

        .control-group label {
            display: block;
            margin-bottom: 2px;
            font-size: 0.85em;
            color: #ccc;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 2px 0;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 25px;
        }
        
        .slider-label {
            font-size: 0.7em; 
        }
    </style>
    
    <!-- SOLUÇÃO FINAL PARA O ERRO: IMPORTMAP NO HEAD -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Carregando Cena...</div>

    <!-- TELA DE CONFIGURAÇÃO -->
    <div id="control-panel">
        <div id="drag-handle">ARRASTE AQUI</div>
        
        <h2 style="margin-top: 0; color: #00ffff; border-bottom: 2px solid #00ffff99; padding-bottom: 8px;">
            Configuração Neon Shader
        </h2>

        <!-- Botão de Fechar Interno -->
        <button id="close-button">
            X
        </button>

        <!-- CONTROLES DE BRILHO (BLOOM) -->
        <div class="control-group">
            <label>Força do Brilho</label>
            <input type="range" id="bloomStrength" min="0.0" max="2.0" step="0.05">
            <div class="slider-label"><span id="bloomStrengthValue">0.40</span></div>
        </div>

        <div class="control-group">
            <label>Raio do Brilho</label>
            <input type="range" id="bloomRadius" min="0.0" max="1.0" step="0.05">
            <div class="slider-label"><span id="bloomRadiusValue">0.15</span></div>
        </div>

        <!-- CONTROLES DE MOVIMENTO -->
        <div class="control-group">
            <label>Velocidade</label>
            <input type="range" id="speedMultiplier" min="0.0" max="0.5" step="0.01">
            <div class="slider-label"><span id="speedMultiplierValue">0.15</span></div>
        </div>
        
        <!-- CONTROLES DE COR -->
        <div class="control-group">
            <label>Cor 1 (Ciano)</label>
            <input type="color" id="color1" value="#00FFFF">
        </div>
        <div class="control-group">
            <label>Cor 2 (Roxo)</label>
            <input type="color" id="color2" value="#D000FF">
        </div>
        <div class="control-group">
            <label>Cor 3 (Laranja)</label>
            <input type="color" id="color3" value="#FF9900">
        </div>
    </div>
    
    <!-- BOTÃO DE ABRIR (ENGRENAGEM) -->
    <button id="toggle-button" aria-label="Abrir Configurações">
        &#9881;
    </button>
    <!-- FIM TELA DE CONFIGURAÇÃO -->

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Variáveis Globais de Configuração ---
        const CONFIG = {
            bloomStrength: 0.4,
            bloomRadius: 0.15,
            speedMultiplier: 0.15,
            color1: '#00FFFF',
            color2: '#D000FF',
            color3: '#FF9900',
        };

        let filmMaterial, bloomPass;
        const clock = new THREE.Clock();

        // --- 1. CENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0.5, 10); 

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.3;
        renderer.setClearColor(0x000000, 0); 
        document.body.appendChild(renderer.domElement);

        // --- 2. PÓS-PROCESSAMENTO ---
        const renderScene = new RenderPass(scene, camera);
        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            CONFIG.bloomStrength, 
            CONFIG.bloomRadius, 
            0.15 
        );

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 40;

        // --- 3. TEXTURA ---
        function createFilmStripTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048; 
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 5; 
            ctx.fillStyle = '#FFFFFF';

            const frameWidth = 512;
            const holeSize = 12;
            const totalFrames = Math.ceil(canvas.width / frameWidth);

            for (let i = 0; i < totalFrames; i++) {
                const x = i * frameWidth;
                
                // Moldura
                ctx.strokeRect(x, 25, frameWidth, canvas.height - 50);

                // Furos
                for (let hx = x + 25; hx < x + frameWidth; hx += 40) {
                    ctx.fillRect(hx, 6, holeSize, holeSize); 
                    ctx.fillRect(hx, canvas.height - 18, holeSize, holeSize);
                }

                // Texto "They do it"
                ctx.save();
                ctx.translate(x + frameWidth / 2, canvas.height / 2);
                ctx.font = '900 70px "Arial Black", Arial, sans-serif'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Texto apenas com contorno
                ctx.strokeText('They do it', 0, 5);
                
                ctx.restore();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.repeat.set(2, 1);
            
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.minFilter = THREE.LinearMipMapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            return texture;
        }

        const filmTexture = createFilmStripTexture();

        // --- 4. MATERIAL ---
        function createFilmMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: filmTexture },
                    uColor1: { value: new THREE.Color(CONFIG.color1) }, 
                    uColor2: { value: new THREE.Color(CONFIG.color2) }, 
                    uColor3: { value: new THREE.Color(CONFIG.color3) }, 
                    uTime: { value: 0 } 
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vProgress;
                    void main() {
                        vUv = uv;
                        vProgress = uv.x;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTexture;
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform vec3 uColor3;
                    uniform float uTime;

                    varying vec2 vUv;
                    varying float vProgress;

                    void main() {
                        vec2 correctUV = vec2(vUv.x, 1.0 - vUv.y);
                        
                        vec2 animatedUv = vec2(correctUV.x - uTime, correctUV.y);
                        
                        vec4 texColor = texture2D(uTexture, animatedUv);

                        // Gradiente
                        vec3 gradientColor;
                        float p = fract(vProgress * 0.75); 
                        
                        if (p < 0.5) {
                            gradientColor = mix(uColor1, uColor2, p * 2.0);
                        } else {
                            gradientColor = mix(uColor2, uColor3, (p - 0.5) * 2.0);
                        }

                        // Renderização
                        float pixelBrightness = texColor.r;

                        vec3 coreColor = vec3(1.0) * pixelBrightness * 2.0; 
                        vec3 tintColor = gradientColor * pixelBrightness * 0.6;
                        vec3 finalColor = coreColor + tintColor;

                        float edge = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 8.0);
                        finalColor += gradientColor * edge * 0.8;

                        float alpha = pixelBrightness + 0.1; 

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
        }

        filmMaterial = createFilmMaterial();

        // --- 5. GEOMETRIA ---
        function createSpiralRibbon() {
            const points = [];
            const turns = 1.5; 
            const height = 3.75; 
            const radius = 1.9;
            const pointCount = 350;

            for (let i = 0; i <= pointCount; i++) {
                const t = i / pointCount;
                const angle = t * Math.PI * 2 * turns;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = (t - 0.5) * height;
                points.push(new THREE.Vector3(x, y, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            
            const ribbonGeo = new THREE.BufferGeometry();
            const positions = [];
            const uvs = [];
            const indices = [];
            
            const segments = 400;
            const width = 1.8 / 2;
            const half_width = width / 2;

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                const p1 = point.clone().add(binormal.clone().multiplyScalar(half_width));
                const p2 = point.clone().add(binormal.clone().multiplyScalar(-half_width));

                const tilt = Math.sin(t * Math.PI * 3) * 0.15 / 2;
                p1.y += tilt;
                p2.y -= tilt;

                positions.push(p1.x, p1.y, p1.z);
                positions.push(p2.x, p2.y, p2.z);

                uvs.push(t * 2.5, 0); 
                uvs.push(t * 2.5, 1);
            }

            for (let i = 0; i < segments; i++) {
                const a = i * 2;
                const b = i * 2 + 1;
                const c = (i + 1) * 2;
                const d = (i + 1) * 2 + 1;
                indices.push(a, b, d);
                indices.push(a, d, c);
            }

            ribbonGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            ribbonGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            ribbonGeo.setIndex(indices);
            ribbonGeo.computeVertexNormals();

            return ribbonGeo;
        }

        const ribbonMesh = new THREE.Mesh(createSpiralRibbon(), filmMaterial);
        scene.add(ribbonMesh);

        // --- 6. FUNÇÕES DRAG-AND-DROP E UI ---

        function setupDrag(element, handle) {
            let isDragging = false;
            let initialX;
            let initialY;

            const dragStart = (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'LABEL') return;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const rect = element.getBoundingClientRect();
                initialX = clientX - rect.left;
                initialY = clientY - rect.top;

                element.style.transition = 'none';
                element.style.position = 'fixed'; 
                
                isDragging = true;
            };

            const dragEnd = () => {
                isDragging = false;
                element.style.transition = 'transform 0.4s ease-out, opacity 0.4s ease-out';
            };

            const drag = (e) => {
                if (!isDragging) return;
                
                e.preventDefault();

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                let newLeft = clientX - initialX;
                let newTop = clientY - initialY;
                
                // Limites para que o painel não saia da tela
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - element.offsetWidth));
                newTop = Math.max(0, Math.min(newTop, window.innerHeight - element.offsetHeight));

                element.style.left = `${newLeft}px`;
                element.style.top = `${newTop}px`;
                element.style.transform = 'none'; // Desativa a transformação CSS de centralização/ocultação
            };

            handle.addEventListener('mousedown', dragStart);
            handle.addEventListener('touchstart', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchend', dragEnd);
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);
        }

        function setupUI() {
            const panel = document.getElementById('control-panel');
            const toggleButton = document.getElementById('toggle-button');
            const closeButton = document.getElementById('close-button');
            const dragHandle = document.getElementById('drag-handle');
            
            // 1. Inicializa o Arraste
            setupDrag(panel, dragHandle);
            
            // 2. Inicializa valores da UI
            document.getElementById('bloomStrength').value = CONFIG.bloomStrength;
            document.getElementById('bloomRadius').value = CONFIG.bloomRadius;
            document.getElementById('speedMultiplier').value = CONFIG.speedMultiplier;
            
            document.getElementById('bloomStrengthValue').textContent = CONFIG.bloomStrength.toFixed(2);
            document.getElementById('bloomRadiusValue').textContent = CONFIG.bloomRadius.toFixed(2);
            document.getElementById('speedMultiplierValue').textContent = CONFIG.speedMultiplier.toFixed(2);

            // Toggle Logic
            const togglePanel = () => {
                const isOpen = panel.classList.toggle('open');
                
                // Oculta/Mostra o botão de engrenagem
                if (!isOpen) {
                    toggleButton.style.opacity = '1';
                    toggleButton.style.pointerEvents = 'auto';
                } else {
                    toggleButton.style.opacity = '0';
                    toggleButton.style.pointerEvents = 'none';
                    // Ao abrir, centraliza na tela (posição padrão)
                    panel.style.left = '50%';
                    panel.style.top = '50%';
                    panel.style.transform = 'translate(-50%, -50%)'; 
                }
            };
            
            // Event Listeners
            toggleButton.addEventListener('click', togglePanel); 
            closeButton.addEventListener('click', togglePanel);   

            // Estado inicial: Garante que o painel comece escondido e o botão visível.
            panel.classList.remove('open'); 
            toggleButton.style.opacity = '1';
            toggleButton.style.pointerEvents = 'auto';


            // Sliders (Bloom)
            document.getElementById('bloomStrength').addEventListener('input', (e) => {
                CONFIG.bloomStrength = parseFloat(e.target.value);
                bloomPass.strength = CONFIG.bloomStrength;
                document.getElementById('bloomStrengthValue').textContent = CONFIG.bloomStrength.toFixed(2);
            });

            document.getElementById('bloomRadius').addEventListener('input', (e) => {
                CONFIG.bloomRadius = parseFloat(e.target.value);
                bloomPass.radius = CONFIG.bloomRadius;
                document.getElementById('bloomRadiusValue').textContent = CONFIG.bloomRadius.toFixed(2);
            });

            // Movimento
            document.getElementById('speedMultiplier').addEventListener('input', (e) => {
                CONFIG.speedMultiplier = parseFloat(e.target.value);
                document.getElementById('speedMultiplierValue').textContent = CONFIG.speedMultiplier.toFixed(2);
            });

            // Cores
            document.getElementById('color1').addEventListener('input', (e) => {
                filmMaterial.uniforms.uColor1.value.set(e.target.value);
            });
            document.getElementById('color2').addEventListener('input', (e) => {
                filmMaterial.uniforms.uColor2.value.set(e.target.value);
            });
            document.getElementById('color3').addEventListener('input', (e) => {
                filmMaterial.uniforms.uColor3.value.set(e.target.value);
            });
        }
        
        setupUI();
        document.getElementById('loading').style.display = 'none';

        // --- 7. LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            
            filmMaterial.uniforms.uTime.value = t * CONFIG.speedMultiplier; 
            
            ribbonMesh.rotation.y = t * 0.1;
            ribbonMesh.position.y = Math.sin(t * 0.5) * 0.1;
            
            controls.update();
            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
            
            setupUI();
        });

        animate();
    </script>
</body>
</html>
