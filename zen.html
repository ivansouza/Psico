<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Zen Sandscape 3D - Física de Matéria Real</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; touch-action: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        .glass {
            background: rgba(15, 15, 15, 0.9);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .ui-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 18px;
            border-radius: 28px;
            width: 95%;
            max-width: 440px;
            color: white;
            user-select: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s ease;
        }
        .ui-hidden { opacity: 0 !important; pointer-events: none; transform: translateX(-50%) translateY(20px); }
        #ui-toggle-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        input[type="range"] { accent-color: #fff; cursor: pointer; }
        .label-text { font-size: 8px; text-transform: uppercase; font-weight: 700; letter-spacing: 0.1em; color: rgba(255,255,255,0.4); }
    </style>
</head>
<body>

    <button id="ui-toggle-btn" class="glass text-white/50 hover:text-white active:scale-90">
        <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>

    <div id="main-ui" class="ui-overlay glass">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-[10px] font-bold uppercase tracking-widest text-gray-500">Simulador Zen Fantasma</h2>
            <span id="speedDisplay" class="text-[10px] font-mono opacity-80">0.1x</span>
        </div>
        
        <div class="space-y-4">
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="label-text mb-1 block">Velocidade</label>
                    <input type="range" id="speedSlider" min="0" max="50" value="1" class="w-full h-1 bg-gray-700 rounded-lg appearance-none">
                </div>
                <div>
                    <label class="label-text mb-1 block">Qtd. Areia</label>
                    <input type="range" id="sandAmountSlider" min="5" max="200" value="60" class="w-full h-1 bg-gray-700 rounded-lg appearance-none">
                </div>
            </div>

            <!-- Painéis de Controlo A e B -->
            <div class="grid grid-cols-3 gap-3 p-2 bg-white/5 rounded-xl border border-white/5">
                <div class="col-span-3 text-[9px] font-bold text-white/30 uppercase text-center">Raio A (Ancinho)</div>
                <div><label class="label-text mb-1 block">Finura</label><input type="range" id="finura1Slider" min="5" max="100" value="20" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
                <div><label class="label-text mb-1 block">Prof.</label><input type="range" id="depth1Slider" min="1" max="40" value="15" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
                <div><label class="label-text mb-1 block">Ângulo</label><input type="range" id="angle1Slider" min="-100" max="100" value="0" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
            </div>

            <div class="grid grid-cols-3 gap-3 p-2 bg-white/5 rounded-xl border border-white/5">
                <div class="col-span-3 text-[9px] font-bold text-white/30 uppercase text-center">Raio B (Nivelador)</div>
                <div><label class="label-text mb-1 block">Finura</label><input type="range" id="finura2Slider" min="5" max="100" value="50" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
                <div><label class="label-text mb-1 block">Prof.</label><input type="range" id="depth2Slider" min="1" max="40" value="10" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
                <div><label class="label-text mb-1 block">Ângulo</label><input type="range" id="angle2Slider" min="-100" max="100" value="0" class="w-full h-1 bg-gray-600 rounded-lg appearance-none"></div>
            </div>

            <div class="flex items-center justify-between p-2 bg-white/5 rounded-xl border border-white/10">
                <label for="orbitToggle" class="text-[10px] uppercase font-semibold cursor-pointer flex-1 text-center">Orbitar Câmara</label>
                <input type="checkbox" id="orbitToggle" class="w-5 h-5 rounded border-gray-600 bg-gray-800 text-white cursor-pointer">
            </div>
            <p class="text-[8px] text-center text-white/30 uppercase tracking-widest mt-1 italic">Cada toque transporta matéria para o lado oposto</p>
        </div>
    </div>

    <!-- SHADERS -->
    <script id="heightmapFragment" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D heightmap;
        uniform vec2 mouse;
        uniform bool isDrawing;
        uniform float brushRadius, armAngle, resolution;
        uniform float rippleFreq1, rippleFreq2, rippleDepth1, rippleDepth2, rippleAngle1, rippleAngle2;
        uniform float sandAmount, uSpeed, transferActive;
        uniform vec2 transferSource, transferTarget;

        float triangle(float x, float freq, float depth) {
            return abs(fract(x * freq) * 2.0 - 1.0) * depth + (0.95 - depth);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / resolution;
            vec2 center = vec2(0.5);
            float dC = distance(uv, center);
            if(dC > 0.495) { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); return; }

            vec4 data = texture2D(heightmap, uv);
            float h = data.r;

            // Arrastre Manual (Suavização da área tocada)
            if(isDrawing) {
                float dM = distance(uv, mouse);
                if(dM < brushRadius * 0.8) h -= (1.0 - (dM / (brushRadius * 0.8))) * 0.05;
            }

            // Lógica de Transporte (Ativada a cada toque ou duplo clique)
            if(transferActive > 0.5) {
                float distS = distance(uv, transferSource);
                float distT = distance(uv, transferTarget);
                float coneRadius = 0.05 + (sandAmount * 0.15);

                // Cone Invertido (Origem): Escava até o fundo
                if(distS < coneRadius) {
                    float falloff = 1.0 - (distS / coneRadius);
                    h = h * (1.0 - falloff);
                }

                // Cone de Areia (Destino): Acumula acima do nível atual
                if(distT < coneRadius) {
                    float falloff = 1.0 - (distT / coneRadius);
                    h += falloff * 0.7; 
                }
            }

            // Lógica da Haste Axial Única
            vec2 dir = vec2(cos(armAngle), sin(armAngle));
            vec2 toP = uv - center;
            float distToLine = abs(toP.x * dir.y - toP.y * dir.x);
            float side = dot(normalize(toP), dir);

            if(distToLine < 0.045 && dC < 0.485 && uSpeed > 0.0) {
                float levelH = 0.88; 
                vec2 radialDir = normalize(toP);
                float shift = (side > 0.0 ? rippleAngle1 : rippleAngle2) * 0.015 * uSpeed * 10.0;
                float movedH = texture2D(heightmap, uv - radialDir * shift).r;
                h = mix(h, movedH, 0.2);

                if(side > 0.0) {
                    float targetH = triangle(dC, rippleFreq1, rippleDepth1);
                    h = mix(h, targetH, (0.1 + (uSpeed * 5.0)) * smoothstep(0.2, 0.5, h)); 
                } else {
                    if (h > levelH) h = mix(h, levelH, 0.08 + (uSpeed * 12.0));
                    else h += pow(sandAmount, 2.5) * uSpeed * 8.0 * (levelH - h); 
                    float targetH = triangle(dC, rippleFreq2, rippleDepth2);
                    h = mix(h, targetH, 0.08 * smoothstep(0.2, 0.5, h));
                    h += (1.0 - smoothstep(0.0, 0.045, distToLine)) * (0.4 * sandAmount * uSpeed); 
                }
            }
            gl_FragColor = vec4(clamp(h, 0.0, 1.0), 0.0, 0.0, 1.0);
        }
    </script>

    <script id="sandVertex" type="x-shader/x-vertex">
        precision highp float;
        uniform sampler2D heightmap;
        uniform float sandScale;
        varying vec2 vUv;
        varying float vHeight;
        void main() {
            vUv = uv;
            vHeight = texture2D(heightmap, uv).r;
            vec3 p = position;
            p.z += vHeight * sandScale; 
            gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
        }
    </script>

    <script id="sandFragment" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D heightmap;
        varying vec2 vUv;
        void main() {
            if(distance(vUv, vec2(0.5)) > 0.495) discard;
            float s = 1.0 / 512.0;
            float hL = texture2D(heightmap, vUv + vec2(-s, 0.0)).r;
            float hR = texture2D(heightmap, vUv + vec2(s, 0.0)).r;
            float hD = texture2D(heightmap, vUv + vec2(0.0, -s)).r;
            float hU = texture2D(heightmap, vUv + vec2(0.0, s)).r;
            vec3 n = normalize(vec3((hL - hR) * 12.0, (hD - hU) * 12.0, 0.12));
            float d = max(dot(n, normalize(vec3(0.5, 0.7, 1.0))), 0.0);
            vec3 sandCol = vec3(0.96, 0.94, 0.88);
            vec3 shadCol = vec3(0.18, 0.16, 0.12);
            gl_FragColor = vec4(mix(shadCol, sandCol, d + 0.12), 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, controls, sandMesh, visualArm, tray;
        let rt1, rt2, simScene, simCam, simMat, dispMat;
        let angle = 0, mouse = new THREE.Vector2(-1, -1), isDrawing = false, speed = 0.001, orbit = false;
        let finura1 = 20.0, finura2 = 50.0, depth1 = 0.15, depth2 = 0.10, sandAmt = 1.2, transferActive = 0;
        const RES = 512;

        function createGhostlySpottedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#39FF14'; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#000000';
            for(let i=0; i<180; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*256, Math.random()*256, Math.random()*10+2, 0, Math.PI*2);
                ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createInitialHeightTexture() {
            const data = new Float32Array(RES * RES * 4);
            for(let i = 0; i < RES * RES; i++) { data[i * 4] = 0.88; data[i * 4 + 3] = 1.0; }
            const tex = new THREE.DataTexture(data, RES, RES, THREE.RGBAFormat, THREE.FloatType);
            tex.needsUpdate = true;
            return tex;
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(42, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, -13, 11);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.enabled = false;

            const gl = renderer.getContext();
            const type = (renderer.capabilities.isWebGL2 || gl.getExtension('OES_texture_float')) ? THREE.FloatType : THREE.HalfFloatType;
            
            const startTex = createInitialHeightTexture();
            rt1 = new THREE.WebGLRenderTarget(RES, RES, { format: THREE.RGBAFormat, type: type });
            rt2 = new THREE.WebGLRenderTarget(RES, RES, { format: THREE.RGBAFormat, type: type });

            renderer.setRenderTarget(rt1);
            const screenScene = new THREE.Scene();
            screenScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: startTex })));
            renderer.render(screenScene, new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1));
            renderer.setRenderTarget(null);

            simScene = new THREE.Scene();
            simCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            simMat = new THREE.ShaderMaterial({
                uniforms: {
                    heightmap: { value: null }, mouse: { value: mouse }, isDrawing: { value: false },
                    brushRadius: { value: 0.055 }, armAngle: { value: 0 }, resolution: { value: RES }, 
                    rippleFreq1: { value: finura1 }, rippleFreq2: { value: finura2 },
                    rippleDepth1: { value: depth1 }, rippleDepth2: { value: depth2 },
                    rippleAngle1: { value: 0.0 }, rippleAngle2: { value: 0.0 },
                    sandAmount: { value: 0.6 }, uSpeed: { value: 0.001 },
                    transferSource: { value: new THREE.Vector2() }, transferTarget: { value: new THREE.Vector2() }, transferActive: { value: 0.0 }
                },
                fragmentShader: document.getElementById('heightmapFragment').textContent
            });
            simScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), simMat));

            dispMat = new THREE.ShaderMaterial({
                uniforms: { heightmap: { value: null }, sandScale: { value: sandAmt } },
                vertexShader: document.getElementById('sandVertex').textContent,
                fragmentShader: document.getElementById('sandFragment').textContent,
                transparent: true
            });
            sandMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10, 256, 256), dispMat);
            scene.add(sandMesh);

            const ghostlyTex = createGhostlySpottedTexture();
            const phantomMat = new THREE.MeshBasicMaterial({ map: ghostlyTex, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
            
            const armGroup = new THREE.Group();
            const rodThickness = 0.15; 
            const rakeA = new THREE.Mesh(new THREE.PlaneGeometry(5, rodThickness), phantomMat); rakeA.position.x = 2.5; armGroup.add(rakeA);
            const rakeB = new THREE.Mesh(new THREE.PlaneGeometry(5, rodThickness), phantomMat); rakeB.position.x = -2.5; armGroup.add(rakeB);
            visualArm = armGroup; visualArm.position.z = 2.5; scene.add(visualArm);

            tray = new THREE.Mesh(new THREE.CylinderGeometry(5.2, 5.2, 1.8, 64, 1, true), phantomMat);
            tray.rotation.x = Math.PI/2; tray.position.z = 0.8; scene.add(tray);
            const trayBottom = new THREE.Mesh(new THREE.CircleGeometry(5.2, 64), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            trayBottom.position.z = -0.01; scene.add(trayBottom);
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));

            document.getElementById('orbitToggle').onchange = (e) => controls.enabled = orbit = e.target.checked;
            document.getElementById('speedSlider').oninput = (e) => {
                const v = e.target.value / 10;
                speed = v * 0.01;
                simMat.uniforms.uSpeed.value = speed;
                document.getElementById('speedDisplay').textContent = v.toFixed(1) + 'x';
            };
            document.getElementById('sandAmountSlider').oninput = (e) => {
                const val = e.target.value / 100;
                sandAmt = val * 2.0; 
                dispMat.uniforms.sandScale.value = sandAmt;
                simMat.uniforms.sandAmount.value = val;
            };
            document.getElementById('finura1Slider').oninput = (e) => simMat.uniforms.rippleFreq1.value = parseFloat(e.target.value);
            document.getElementById('finura2Slider').oninput = (e) => simMat.uniforms.rippleFreq2.value = parseFloat(e.target.value);
            document.getElementById('depth1Slider').oninput = (e) => simMat.uniforms.rippleDepth1.value = e.target.value / 100;
            document.getElementById('depth2Slider').oninput = (e) => simMat.uniforms.rippleDepth2.value = e.target.value / 100;
            document.getElementById('angle1Slider').oninput = (e) => simMat.uniforms.rippleAngle1.value = e.target.value / 100;
            document.getElementById('angle2Slider').oninput = (e) => simMat.uniforms.rippleAngle2.value = e.target.value / 100;

            document.getElementById('ui-toggle-btn').onclick = function() {
                const ui = document.getElementById('main-ui');
                const isHidden = ui.classList.toggle('ui-hidden');
                this.innerHTML = isHidden ? '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>';
            };

            setupInteraction();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            animate();
        }

        function setupInteraction() {
            const ray = new THREE.Raycaster();
            const getUV = (cx, cy) => {
                const v = new THREE.Vector2((cx/window.innerWidth)*2-1, -(cy/window.innerHeight)*2+1);
                ray.setFromCamera(v, camera);
                const hits = ray.intersectObject(sandMesh);
                if (hits.length > 0) return new THREE.Vector2((hits[0].point.x + 5) / 10, (hits[0].point.y + 5) / 10);
                return null;
            };

            window.addEventListener('pointerdown', (e) => { 
                if(!orbit && !e.target.closest('#main-ui') && !e.target.closest('#ui-toggle-btn')) {
                    const uv = getUV(e.clientX, e.clientY);
                    if(uv) {
                        mouse.copy(uv);
                        isDrawing = true;
                        // ATUALIZAÇÃO: Aciona o pulso de transporte a cada toque
                        simMat.uniforms.transferSource.value.copy(uv);
                        simMat.uniforms.transferTarget.value.set(1.0 - uv.x, 1.0 - uv.y);
                        transferActive = 1.0;
                    }
                }
            });

            // Duplo clique permanece como funcionalidade redundante ou reforçada
            window.addEventListener('dblclick', (e) => {
                if(!e.target.closest('#main-ui') && !e.target.closest('#ui-toggle-btn')) {
                    const uv = getUV(e.clientX, e.clientY);
                    if(uv) {
                        simMat.uniforms.transferSource.value.copy(uv);
                        simMat.uniforms.transferTarget.value.set(1.0 - uv.x, 1.0 - uv.y);
                        transferActive = 1.0;
                    }
                }
            });

            window.addEventListener('pointermove', (e) => { if(isDrawing) { const uv = getUV(e.clientX, e.clientY); if(uv) mouse.copy(uv); } });
            window.addEventListener('pointerup', () => isDrawing = false);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (orbit) controls.update();
            angle += speed; if(visualArm) visualArm.rotation.z = angle;
            simMat.uniforms.transferActive.value = transferActive;
            if(transferActive > 0) transferActive -= 0.1;
            simMat.uniforms.heightmap.value = rt1.texture;
            simMat.uniforms.isDrawing.value = isDrawing && !orbit;
            simMat.uniforms.mouse.value = mouse;
            simMat.uniforms.armAngle.value = angle;
            renderer.setRenderTarget(rt2);
            renderer.render(simScene, simCam);
            let tmp = rt1; rt1 = rt2; rt2 = tmp;
            dispMat.uniforms.heightmap.value = rt1.texture;
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>

