<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Gaussian Wave Packet</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', Roboto, sans-serif; }
        canvas { display: block; }
        
        /* Gear Button */
        #settings-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            background: rgba(30, 30, 35, 0.9);
            border: 1px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            user-select: none;
        }
        #settings-btn:hover {
            background: #00ffff;
            color: #000;
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        /* Settings Panel */
        #ui-container {
            position: absolute;
            top: 75px;
            left: 20px;
            width: 320px;
            color: #e0e0e0;
            background: rgba(18, 18, 24, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            backdrop-filter: blur(12px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
            
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            pointer-events: none;
            transition: all 0.3s ease-out;
            z-index: 99;
            max-height: 80vh;
            overflow-y: auto;
        }

        #ui-container.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        /* Typography & Layout */
        h1 { margin: 0 0 15px 0; font-size: 1.1rem; color: #00ffff; border-bottom: 1px solid #333; padding-bottom: 10px; font-weight: 600; letter-spacing: 0.5px; }
        
        .math-eq {
            font-family: 'Courier New', monospace;
            background: #000;
            padding: 10px;
            border-radius: 6px;
            color: #0f0;
            border: 1px solid #333;
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        /* Custom Sliders */
        .control-group { margin-bottom: 15px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 0.85rem; color: #aaa; margin-bottom: 5px; }
        .control-group span { color: #fff; font-weight: bold; }
        
        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 5px rgba(0,255,255,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }

        /* Buttons */
        .btn-row { display: flex; gap: 10px; margin-top: 20px; }
        
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn-primary { background: #2a2a35; color: white; border: 1px solid #555; }
        .btn-primary:hover { background: #00ffff; color: #000; }
        
        .btn-stack { display: flex; flex-direction: column; gap: 8px; margin-top: 15px; }

        .btn-save { background: #1a441a; color: #4caf50; border: 1px solid #2e7d32; width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .btn-save:hover { background: #2e7d32; color: #fff; }
        
        .btn-copy { background: #1a3c44; color: #4dd0e1; border: 1px solid #0097a7; width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;}
        .btn-copy:hover { background: #0097a7; color: #fff; }

        button:active { transform: scale(0.98); }

        /* Legend */
        .legend { margin-top: 15px; font-size: 0.8rem; border-top: 1px solid #333; padding-top: 15px; }
        .item { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; color: #ccc; }
        .color-box { width: 12px; height: 12px; border-radius: 3px; }

        /* Floating Labels */
        .axis-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.95);
            font-weight: 700;
            font-size: 13px;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 4px #000;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            white-space: nowrap;
            z-index: 10;
        }

        /* Footer Instructions */
        .instructions {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            pointer-events: none;
            user-select: none;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            letter-spacing: 0.5px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="settings-btn" title="Settings">‚öôÔ∏è</div>

<div id="ui-container">
    <h1>Wave Configuration</h1>
    <div class="math-eq">œà(t) = A¬∑e<sup>-Œ≥t¬≤</sup> ¬∑ e<sup>iœât</sup></div>

    <div class="control-group">
        <label>Amplitude (A): <span id="val-amp">3.5</span></label>
        <input type="range" id="inp-amp" min="1.0" max="6.0" step="0.1" value="3.5">
    </div>

    <div class="control-group">
        <label>Frequency (œâ): <span id="val-omega">2.5</span></label>
        <input type="range" id="inp-omega" min="0.5" max="8.0" step="0.1" value="2.5">
    </div>

    <div class="control-group">
        <label>Packet Width (Œ≥): <span id="val-gamma">0.04</span></label>
        <input type="range" id="inp-gamma" min="0.01" max="0.15" step="0.005" value="0.04">
    </div>

    <div class="btn-row">
        <button class="btn-primary" id="btn-pause">Pause</button>
        <button class="btn-primary" id="btn-reset">Reset</button>
    </div>

    <div class="btn-stack">
        <button class="btn-save" id="btn-save">
            <span>üíæ</span> Save State
        </button>
        <button class="btn-copy" id="btn-copy">
            <span>üìã</span> Copy JSON
        </button>
    </div>
    
    <div class="legend">
        <div class="item"><div class="color-box" style="background: #00ffff;"></div><span>Complex Wave (3D)</span></div>
        <div class="item"><div class="color-box" style="background: #ff00ff;"></div><span>Real Part (Projection)</span></div>
        <div class="item"><div class="color-box" style="background: #00ff00;"></div><span>Imaginary Part (Projection)</span></div>
        <div class="item"><div class="color-box" style="background: #0088ff;"></div><span>Phase Plane (Orthogonal)</span></div>
    </div>
</div>

<div id="labels-container"></div>

<div class="instructions">
    Rotate: Left Click | Zoom: Scroll | Pan: Right Click
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const defaultParams = {
        gamma: 0.04,
        omega: 2.5,
        tMin: -25,
        tMax: 25,
        resolution: 1500,
        amplitude: 3.5,
        offset: 5.5
    };

    let params = { ...defaultParams };

    const ui = {
        container: document.getElementById('ui-container'),
        btnSettings: document.getElementById('settings-btn'),
        inpAmp: document.getElementById('inp-amp'),
        inpOmega: document.getElementById('inp-omega'),
        inpGamma: document.getElementById('inp-gamma'),
        valAmp: document.getElementById('val-amp'),
        valOmega: document.getElementById('val-omega'),
        valGamma: document.getElementById('val-gamma'),
        btnPause: document.getElementById('btn-pause'),
        btnReset: document.getElementById('btn-reset'),
        btnSave: document.getElementById('btn-save'),
        btnCopy: document.getElementById('btn-copy'),
    };

    let isMenuVisible = false;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.012);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20.16, 13.58, -38.52);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);

    // --- Original Formula Logic Restored & Extended ---
    function createFormulaTexture(type) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 256;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Color Selection based on Projection
        if (type === 'Re') ctx.fillStyle = '#ff00ff';
        else if (type === 'Im') ctx.fillStyle = '#00ff00';
        else if (type === 'Phase') ctx.fillStyle = '#0088ff';
        
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const mainFont = "bold 60px 'Segoe UI', Arial, sans-serif";
        const subFont = "bold 40px 'Segoe UI', Arial, sans-serif";
        ctx.font = mainFont;
        
        // Segment Data
        let prefix = "";
        let base = "e";
        let exponent = "-Œ≥(t-t‚ÇÄ)¬≤";
        let suffix = "";

        if (type === 'Re') {
            prefix = "Re f = ";
            suffix = " cos(œât)";
        } else if (type === 'Im') {
            prefix = "Im f = ";
            suffix = " sin(œât)";
        } else {
            prefix = "œà(t) = ";
            exponent = "-Œ≥(t-t‚ÇÄ)¬≤ + iœât";
            suffix = "";
        }
        
        const prefixWidth = ctx.measureText(prefix).width;
        const baseWidth = ctx.measureText(base).width;
        ctx.font = subFont;
        const expWidth = ctx.measureText(exponent).width;
        ctx.font = mainFont;
        const suffixWidth = ctx.measureText(suffix).width;
        
        const totalWidth = prefixWidth + baseWidth + expWidth + suffixWidth;
        let currentX = cx - totalWidth / 2;
        
        ctx.fillText(prefix, currentX + prefixWidth/2, cy);
        currentX += prefixWidth;
        ctx.fillText(base, currentX + baseWidth/2, cy);
        currentX += baseWidth;
        ctx.font = subFont;
        ctx.fillText(exponent, currentX + expWidth/2, cy - 25); 
        currentX += expWidth;
        ctx.font = mainFont;
        ctx.fillText(suffix, currentX + suffixWidth/2, cy);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return texture;
    }

    const texReal = createFormulaTexture('Re');
    const texImag = createFormulaTexture('Im');
    const texPhase = createFormulaTexture('Phase');

    let waveMesh, lineReal, lineImag, lineOrth, gridReal, gridImag, gridOrth;
    let planeFormulaReal, planeFormulaImag, planeFormulaOrth;
    let points3D = [], pointsReal = [], pointsImag = [], pointsOrth = [];

    function updateWaveGeometry() {
        if (waveMesh) { waveMesh.geometry.dispose(); scene.remove(waveMesh); }
        if (lineReal) { lineReal.geometry.dispose(); scene.remove(lineReal); }
        if (lineImag) { lineImag.geometry.dispose(); scene.remove(lineImag); }
        if (lineOrth) { lineOrth.geometry.dispose(); scene.remove(lineOrth); }
        if (gridReal) scene.remove(gridReal);
        if (gridImag) scene.remove(gridImag);
        if (gridOrth) scene.remove(gridOrth);
        if (planeFormulaReal) scene.remove(planeFormulaReal);
        if (planeFormulaImag) scene.remove(planeFormulaImag);
        if (planeFormulaOrth) scene.remove(planeFormulaOrth);

        points3D = []; pointsReal = []; pointsImag = []; pointsOrth = [];

        const dynamicOffset = params.amplitude + 2.0;
        const floorY = -dynamicOffset;
        const wallX = -dynamicOffset;
        const backZ = params.tMax + 4.0;

        for (let i = 0; i <= params.resolution; i++) {
            const t = params.tMin + (params.tMax - params.tMin) * (i / params.resolution);
            const envelope = params.amplitude * Math.exp(-params.gamma * t * t);
            const real = envelope * Math.cos(params.omega * t);
            const imag = envelope * Math.sin(params.omega * t);
            
            const p = new THREE.Vector3(real, imag, t);
            points3D.push(p);
            pointsReal.push(new THREE.Vector3(p.x, floorY, p.z));
            pointsImag.push(new THREE.Vector3(wallX, p.y, p.z));
            pointsOrth.push(new THREE.Vector3(real, imag, backZ));
        }

        // Wave Tube
        const curvePath = new THREE.CatmullRomCurve3(points3D);
        const tubeGeo = new THREE.TubeGeometry(curvePath, 800, 0.08, 8, false);
        waveMesh = new THREE.Mesh(tubeGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff }));
        scene.add(waveMesh);

        // Lines
        lineReal = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsReal), new THREE.LineBasicMaterial({ color: 0xff00ff, opacity: 0.6, transparent: true }));
        scene.add(lineReal);
        lineImag = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsImag), new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.6, transparent: true }));
        scene.add(lineImag);
        lineOrth = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsOrth), new THREE.LineBasicMaterial({ color: 0x0088ff, opacity: 0.8, transparent: true }));
        scene.add(lineOrth);

        // Grids
        const gridColor = 0x333333; const subGridColor = 0x111111;
        gridReal = new THREE.GridHelper(60, 30, gridColor, subGridColor);
        gridReal.position.y = floorY;
        scene.add(gridReal);

        gridImag = new THREE.GridHelper(60, 30, gridColor, subGridColor);
        gridImag.rotation.z = Math.PI / 2;
        gridImag.position.x = wallX;
        scene.add(gridImag);

        gridOrth = new THREE.GridHelper(20, 10, gridColor, subGridColor);
        gridOrth.rotation.x = Math.PI / 2;
        gridOrth.position.z = backZ;
        scene.add(gridOrth);

        // Labels
        const planeGeo = new THREE.PlaneGeometry(16, 4);
        const labelMargin = 2.0;

        planeFormulaReal = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: texReal, transparent: true, side: THREE.DoubleSide }));
        planeFormulaReal.position.set(params.amplitude + labelMargin + 2, floorY + 0.1, 0); 
        planeFormulaReal.rotation.set(-Math.PI / 2, 0, -Math.PI / 2);
        scene.add(planeFormulaReal);

        planeFormulaImag = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: texImag, transparent: true, side: THREE.DoubleSide }));
        planeFormulaImag.position.set(wallX + 0.1, params.amplitude + labelMargin + 2, 0); 
        planeFormulaImag.rotation.y = Math.PI / 2;
        scene.add(planeFormulaImag);

        planeFormulaOrth = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: texPhase, transparent: true, side: THREE.DoubleSide }));
        planeFormulaOrth.position.set(0, params.amplitude + labelMargin + 1, backZ);
        scene.add(planeFormulaOrth);

        labelPositions.floorY = floorY;
        labelPositions.wallX = wallX;
        labelPositions.backZ = backZ;
    }

    const slicerGroup = new THREE.Group();
    scene.add(slicerGroup);
    const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00);
    slicerGroup.add(arrowHelper);

    let slicerPlane;
    function updateSlicerPlane() {
        if(slicerPlane) { slicerPlane.geometry.dispose(); slicerGroup.remove(slicerPlane); }
        const size = (params.amplitude + 2.0) * 2.5;
        slicerPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(size, size),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.04, side: THREE.DoubleSide, depthWrite: false })
        );
        slicerGroup.add(slicerPlane);
    }

    const sphereGeo = new THREE.SphereGeometry(0.2, 16, 16);
    const pointMain = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
    slicerGroup.add(pointMain);
    const pointReal = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0xff00ff }));
    scene.add(pointReal);
    const pointImag = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
    scene.add(pointImag);
    const pointOrth = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0x0088ff }));
    scene.add(pointOrth);

    const timeAxisGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, params.tMin), new THREE.Vector3(0, 0, params.tMax)]);
    scene.add(new THREE.Line(timeAxisGeo, new THREE.LineBasicMaterial({ color: 0x555555, dashed: true })));

    const labelPositions = { floorY: -5.5, wallX: -5.5, backZ: 29 };
    const labels = {
        real: { el: document.createElement('div'), text: 'Re' },
        imag: { el: document.createElement('div'), text: 'Im' },
        time: { el: document.createElement('div'), text: 't' }
    };

    const labelContainer = document.getElementById('labels-container');
    Object.values(labels).forEach(l => {
        l.el.className = 'axis-label';
        l.el.textContent = l.text;
        labelContainer.appendChild(l.el);
    });

    updateWaveGeometry();
    updateSlicerPlane();

    const handleParamChange = () => {
        params.amplitude = parseFloat(ui.inpAmp.value);
        params.omega = parseFloat(ui.inpOmega.value);
        params.gamma = parseFloat(ui.inpGamma.value);
        ui.valAmp.textContent = params.amplitude.toFixed(1);
        ui.valOmega.textContent = params.omega.toFixed(1);
        ui.valGamma.textContent = params.gamma.toFixed(3);
        updateWaveGeometry();
        updateSlicerPlane();
    };

    ui.inpAmp.addEventListener('input', handleParamChange);
    ui.inpOmega.addEventListener('input', handleParamChange);
    ui.inpGamma.addEventListener('input', handleParamChange);
    ui.btnSettings.addEventListener('click', () => {
        isMenuVisible = !isMenuVisible;
        ui.container.classList.toggle('visible', isMenuVisible);
    });

    let isPaused = false;
    let time = params.tMin;
    const timeSpeed = 0.08;

    ui.btnPause.addEventListener('click', () => { isPaused = !isPaused; ui.btnPause.textContent = isPaused ? "Resume" : "Pause"; });
    ui.btnReset.addEventListener('click', () => { time = params.tMin; isPaused = false; });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (!isPaused) {
            time += timeSpeed;
            if (time > params.tMax) time = params.tMin;
        }

        slicerGroup.position.z = time;
        const envelope = params.amplitude * Math.exp(-params.gamma * time * time);
        const real = envelope * Math.cos(params.omega * time);
        const imag = envelope * Math.sin(params.omega * time);

        const len = Math.sqrt(real*real + imag*imag);
        if (len > 0.001) {
            arrowHelper.setDirection(new THREE.Vector3(real, imag, 0).normalize());
            arrowHelper.setLength(len);
        }

        pointMain.position.set(real, imag, 0);
        pointReal.position.set(real, labelPositions.floorY, time);
        pointImag.position.set(labelPositions.wallX, imag, time);
        pointOrth.position.set(real, imag, labelPositions.backZ);

        updateLabels();
        renderer.render(scene, camera);
    }

    function updateLabels() {
        const widthHalf = window.innerWidth / 2;
        const heightHalf = window.innerHeight / 2;
        const posReal = new THREE.Vector3(params.amplitude + 2, labelPositions.floorY, 0);
        const posImag = new THREE.Vector3(labelPositions.wallX, params.amplitude + 2, 0);
        const posTime = new THREE.Vector3(0, 0, params.tMax + 2);

        function projectAndSet(obj, pos3D) {
            const v = pos3D.clone().project(camera);
            if (v.z < 1 && v.z > -1) {
                obj.el.style.display = 'block';
                const x = (v.x * widthHalf) + widthHalf;
                const y = -(v.y * heightHalf) + heightHalf;
                obj.el.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                obj.el.style.left = '0'; obj.el.style.top = '0';
            } else { obj.el.style.display = 'none'; }
        }
        projectAndSet(labels.real, posReal);
        projectAndSet(labels.imag, posImag);
        projectAndSet(labels.time, posTime);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

