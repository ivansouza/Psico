<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roda Quadrada de Metal - Mobile Friendly</title>
    <style>
        body { margin: 0; overflow: hidden; background: #10151a; font-family: 'Inter', sans-serif; touch-action: none; }
        
        /* UI Principal */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: #ffffff;
            pointer-events: none;
            z-index: 10;
            transition: all 0.3s ease;
        }
        .label { font-size: 10px; text-transform: uppercase; letter-spacing: 3px; color: #00ffcc; font-weight: bold; }
        .title { font-size: 20px; font-weight: 300; margin-top: 5px; }
        
        /* Botões Inferiores */
        #controls-ui {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            width: calc(100% - 40px);
            justify-content: center;
        }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.5);
            color: #00ffcc;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(15px);
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 1px;
            white-space: nowrap;
        }
        button:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }

        /* Ícone de Engrenagem */
        #gear-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 204, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            transition: transform 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #gear-icon svg { fill: #00ffcc; width: 24px; height: 24px; }

        /* Painel de Configurações */
        #settings-panel {
            position: absolute;
            top: 0;
            right: -100%;
            width: 320px;
            max-width: 85%;
            height: 100vh;
            background: rgba(16, 21, 26, 0.9);
            backdrop-filter: blur(25px);
            border-left: 1px solid rgba(0, 255, 204, 0.3);
            padding: 30px;
            box-sizing: border-box;
            color: white;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 25;
            overflow-y: auto;
        }
        #settings-panel.open { right: 0; }
        #settings-panel h3 { 
            margin-top: 0; 
            border-bottom: 1px solid rgba(0, 255, 204, 0.3); 
            padding-bottom: 10px;
            color: #00ffcc;
            font-weight: 300;
            text-transform: uppercase;
            font-size: 16px;
        }

        .setting-group { margin-bottom: 18px; }
        .setting-group label { display: block; font-size: 10px; text-transform: uppercase; margin-bottom: 8px; opacity: 0.7; }
        
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00ffcc; height: 20px; }
        input[type="color"] { width: 100%; height: 34px; border: none; background: none; cursor: pointer; }
        
        .value-display { float: right; color: #00ffcc; font-size: 10px; }

        #instructions {
            position: absolute;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            width: 100%;
            text-align: center;
        }

        /* Ajustes Responsivos para Mobile */
        @media (max-width: 600px) {
            #ui { text-align: center; top: 80px; }
            .title { font-size: 18px; }
            #gear-icon { top: 20px; right: 50%; transform: translateX(50%); }
            #gear-icon:hover { transform: translateX(50%) rotate(90deg); }
            #settings-panel { max-width: 90%; }
        }
    </style>
</head>
<body>

<div id="ui">
    <div class="label">Geometria de CONTATO</div>
    <div class="title">Cubo como uma roda</div>
    <div style="font-size: 11px; margin-top: 5px; opacity: 0.8;">Girando com apoio de arcos</div>
</div>

<div id="gear-icon" onclick="toggleSettings()">
    <svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.91,7.62,6.29L5.23,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.72,8.87 c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.84,11.36,4.81,11.68,4.81,12c0,0.32,0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
</div>

<div id="settings-panel">
    <h3>Definições</h3>
    
    <div class="setting-group">
        <label>Velocidade <span id="val-speed" class="value-display">0.008</span></label>
        <input type="range" id="input-speed" min="0" max="0.04" step="0.001" value="0.008">
    </div>

    <div class="setting-group">
        <label>Lado do Cubo <span id="val-size" class="value-display">2.0</span></label>
        <input type="range" id="input-size" min="1.0" max="4.0" step="0.1" value="2.0">
    </div>

    <div class="setting-group">
        <label>Qtd. de Arcos <span id="val-arches" class="value-display">16</span></label>
        <input type="range" id="input-arches" min="4" max="32" step="1" value="16">
    </div>

    <div class="setting-group">
        <label>Cor do Cubo</label>
        <input type="color" id="input-color-cube" value="#eeeeee">
    </div>

    <div class="setting-group">
        <label>Cor do Rastro</label>
        <input type="color" id="input-color-trail" value="#ff0000">
    </div>

    <div class="setting-group">
        <label>Intensidade Rastro <span id="val-trail-len" class="value-display">800</span></label>
        <input type="range" id="input-trail-len" min="0" max="2000" step="50" value="800">
    </div>

    <div class="setting-group">
        <label>Exposição <span id="val-exposure" class="value-display">1.8</span></label>
        <input type="range" id="input-exposure" min="0.5" max="3.0" step="0.1" value="1.8">
    </div>

    <button onclick="resetToDefaults()" style="width: 100%; margin-top: 10px;">Reset Padronizado</button>
</div>

<div id="instructions">Toque e arraste para rodar | Zoom com dois dedos</div>

<div id="controls-ui">
    <button id="playPause">Pausar</button>
    <button id="resetCamera">Reset Câmara</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    let scene, camera, renderer, cube, track, pivot, controls, gridHelper, floor, ring, pin;
    let isMoving = true;
    let angle = 0;
    let outerMarker, innerMarker;
    let trailPoints = [];

    let config = {
        speed: 0.008,
        cubeSize: 2.0,
        numArches: 16,
        cubeColor: '#eeeeee',
        trailColor: '#ff0000',
        exposure: 1.8,
        maxTrailPoints: 800,
        pinExtension: 1.5
    };

    let SIDE, HALF_SIDE, NUM_ARCHES, RADIUS, CIRCUMFERENCE, VALLEY_Y, MARKER_OFFSET;

    function toggleSettings() {
        document.getElementById('settings-panel').classList.toggle('open');
    }

    function updateCalculatedValues() {
        SIDE = config.cubeSize;
        HALF_SIDE = SIDE / 2.0;
        NUM_ARCHES = config.numArches;
        MARKER_OFFSET = HALF_SIDE + config.pinExtension;

        const xForHalfSide = HALF_SIDE * Math.asinh(1.0);
        const archWidthX = xForHalfSide * 2;
        CIRCUMFERENCE = NUM_ARCHES * archWidthX;
        RADIUS = CIRCUMFERENCE / (Math.PI * 2);
        VALLEY_Y = -HALF_SIDE * Math.sqrt(2.0);
    }

    function init() {
        updateCalculatedValues();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x10151a); 
        scene.fog = new THREE.FogExp2(0x10151a, 0.015);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = config.exposure; 
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 100;

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemiLight);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
        mainLight.position.set(20, 30, 20);
        scene.add(mainLight);

        const followLight = new THREE.PointLight(0xffffff, 3, 20);
        scene.add(followLight);
        scene.followLight = followLight;

        pivot = new THREE.Group();
        scene.add(pivot);

        scene.trailGroup = new THREE.Group();
        scene.add(scene.trailGroup);

        buildScene();
        setupUIEvents();
        updateCameraByAspect();
        window.addEventListener('resize', onResize);
        animate();
    }

    function updateCameraByAspect() {
        const aspect = window.innerWidth / window.innerHeight;
        // No telemóvel (vertical), afastamos a câmara para o círculo caber
        const baseDistance = aspect < 1 ? RADIUS * 5 : 22;
        camera.position.set(baseDistance, baseDistance * 0.7, baseDistance);
        camera.lookAt(0, 0, 0);
        controls.target.set(0, 0, 0);
    }

    function buildScene() {
        if (track) scene.remove(track);
        if (gridHelper) scene.remove(gridHelper);
        if (floor) scene.remove(floor);
        if (ring) scene.remove(ring);
        if (cube) pivot.remove(cube);
        clearTrail();

        gridHelper = new THREE.GridHelper(150, 60, 0x00ffcc, 0x222222);
        gridHelper.position.y = VALLEY_Y; 
        scene.add(gridHelper);

        const floorGeo = new THREE.PlaneGeometry(300, 300);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0x080c10, 
            roughness: 0.8, 
            metalness: 0.2,
            transparent: true,
            opacity: 0.5
        });
        floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = VALLEY_Y - 0.01;
        scene.add(floor);

        const cubeGeo = new THREE.BoxGeometry(SIDE, SIDE, SIDE);
        const cubeMat = new THREE.MeshStandardMaterial({
            color: config.cubeColor,      
            metalness: 1.0,       
            roughness: 0.05,       
            emissive: 0x00ffff,
            emissiveIntensity: 0.02
        });
        cube = new THREE.Mesh(cubeGeo, cubeMat);
        cube.position.set(RADIUS, 0, 0);
        pivot.add(cube);

        addFaceMarkersAndPin(cube);
        createTrack();

        ring = new THREE.Mesh(
            new THREE.TorusGeometry(RADIUS, 0.008, 8, 200),
            new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.2 })
        );
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);
    }

    function addFaceMarkersAndPin(parent) {
        const pinGeo = new THREE.CylinderGeometry(0.06, 0.06, MARKER_OFFSET * 2, 16);
        const pinMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1.0, roughness: 0.1 });
        pin = new THREE.Mesh(pinGeo, pinMat);
        pin.rotation.z = Math.PI / 2; 
        parent.add(pin);

        const markerGeo = new THREE.SphereGeometry(0.1, 12, 12);
        const faceConfigs = [
            { pos: [MARKER_OFFSET, 0, 0], color: config.trailColor, type: 'outer' }, 
            { pos: [-MARKER_OFFSET, 0, 0], color: config.trailColor, type: 'inner' }
        ];

        faceConfigs.forEach(cfg => {
            const mat = new THREE.MeshBasicMaterial({ color: cfg.color });
            const marker = new THREE.Mesh(markerGeo, mat);
            marker.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
            parent.add(marker);
            if (cfg.type === 'outer') outerMarker = marker;
            if (cfg.type === 'inner') innerMarker = marker;
            const light = new THREE.PointLight(cfg.color, 1.5, 3);
            marker.add(light);
        });
    }

    function createTrack() {
        const segmentsPerArch = 80;
        const totalSegments = segmentsPerArch * NUM_ARCHES;
        const trackWidth = 5;
        const geometry = new THREE.PlaneGeometry(trackWidth, CIRCUMFERENCE, 10, totalSegments);
        const pos = geometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            const w = pos.getX(i); 
            const l = pos.getY(i) + CIRCUMFERENCE / 2; 
            const theta = (l / CIRCUMFERENCE) * Math.PI * 2;
            const archLengthDist = CIRCUMFERENCE / NUM_ARCHES;
            let localL = (l % archLengthDist);
            if (localL > archLengthDist / 2) localL -= archLengthDist;
            const a = HALF_SIDE;
            const y = -a * Math.cosh(localL / a);
            const r = RADIUS + w;
            const finalX = Math.cos(theta) * r;
            const finalZ = Math.sin(theta) * r;
            const finalY = y;
            pos.setXYZ(i, finalX, finalY, finalZ);
        }
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({ color: 0x2a3038, roughness: 0.4, metalness: 0.3, side: THREE.DoubleSide });
        track = new THREE.Mesh(geometry, material);
        scene.add(track);
    }

    function clearTrail() {
        while(scene.trailGroup.children.length > 0) {
            const obj = scene.trailGroup.children[0];
            obj.geometry.dispose();
            obj.material.dispose();
            scene.trailGroup.remove(obj);
        }
        trailPoints = [];
    }

    function spawnTrailPoint(marker) {
        if (!marker) return;
        const worldPos = new THREE.Vector3();
        marker.getWorldPosition(worldPos);

        const trailNodeGeo = new THREE.SphereGeometry(0.045, 8, 8);
        const trailNodeMat = new THREE.MeshBasicMaterial({ 
            color: config.trailColor, 
            transparent: true, 
            opacity: 1.0 
        });
        const trailNode = new THREE.Mesh(trailNodeGeo, trailNodeMat);
        trailNode.position.copy(worldPos);
        
        scene.trailGroup.add(trailNode);
        trailPoints.push({ mesh: trailNode });
    }

    function updateTrail() {
        spawnTrailPoint(outerMarker);
        spawnTrailPoint(innerMarker);

        const fadeSpeed = 0.0016; 

        for (let i = trailPoints.length - 1; i >= 0; i--) {
            const node = trailPoints[i].mesh;
            node.material.opacity -= fadeSpeed;
            const s = Math.max(0, node.material.opacity);
            node.scale.set(s, s, s);

            if (node.material.opacity <= 0) {
                scene.trailGroup.remove(node);
                node.geometry.dispose();
                node.material.dispose();
                trailPoints.splice(i, 1);
            }
        }

        if (trailPoints.length > config.maxTrailPoints * 2) {
            const oldObj = trailPoints.shift();
            scene.trailGroup.remove(oldObj.mesh);
            oldObj.mesh.geometry.dispose();
            oldObj.mesh.material.dispose();
        }
    }

    function setupUIEvents() {
        const updateSetting = (id, key, needsRebuild = false) => {
            const el = document.getElementById(id);
            const display = document.getElementById('val-' + id.split('-')[1]);
            el.addEventListener('input', (e) => {
                const val = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value;
                config[key] = val;
                if (display) display.innerText = val;
                
                if (key === 'exposure') {
                    renderer.toneMappingExposure = val;
                } else if (key === 'cubeColor') {
                    cube.material.color.set(val);
                } else if (needsRebuild) {
                    updateCalculatedValues();
                    buildScene();
                }
            });
        };

        updateSetting('input-speed', 'speed');
        updateSetting('input-size', 'cubeSize', true);
        updateSetting('input-arches', 'numArches', true);
        updateSetting('input-color-cube', 'cubeColor');
        updateSetting('input-color-trail', 'trailColor');
        updateSetting('input-trail-len', 'maxTrailPoints');
        updateSetting('input-exposure', 'exposure');

        document.getElementById('playPause').onclick = (e) => {
            isMoving = !isMoving;
            e.target.innerText = isMoving ? "Pausar" : "Continuar";
        };
        document.getElementById('resetCamera').onclick = () => {
            updateCameraByAspect();
        };
    }

    function resetToDefaults() {
        config = {
            speed: 0.008,
            cubeSize: 2.0,
            numArches: 16,
            cubeColor: '#eeeeee',
            trailColor: '#ff0000',
            exposure: 1.8,
            maxTrailPoints: 800,
            pinExtension: 1.5
        };
        
        const syncRange = (id, key) => {
            document.getElementById(id).value = config[key];
            const display = document.getElementById('val-' + id.split('-')[1]);
            if (display) display.innerText = config[key];
        };
        syncRange('input-speed', 'speed');
        syncRange('input-size', 'cubeSize');
        syncRange('input-arches', 'numArches');
        syncRange('input-trail-len', 'maxTrailPoints');
        syncRange('input-exposure', 'exposure');
        document.getElementById('input-color-cube').value = config.cubeColor;
        document.getElementById('input-color-trail').value = config.trailColor;

        updateCalculatedValues();
        buildScene();
        renderer.toneMappingExposure = config.exposure;
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Não resetamos a posição da câmara violentamente no resize para não quebrar a interação do utilizador,
        // mas mantemos a lógica de ajuste se necessário.
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isMoving) {
            angle += config.speed;
            pivot.rotation.y = angle;

            const rollRotation = -(angle / (Math.PI * 2 / NUM_ARCHES)) * (Math.PI / 2);
            cube.rotation.x = rollRotation;

            const lX = Math.cos(angle) * (RADIUS + 2);
            const lZ = Math.sin(angle) * (RADIUS + 2);
            scene.followLight.position.set(lX, 4, lZ);

            updateTrail();
        }

        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>

