<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Twigl Shader - Touch Control</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: move; /* Indica que é interagível */
        }
        #error-log {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 999;
            white-space: pre-wrap;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-family: sans-serif;
            pointer-events: none;
            font-size: 14px;
            text-shadow: 0 1px 2px black;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="error-log"></div>
    <canvas id="glcanvas"></canvas>
    <div id="ui">1 Dedo: Rodar • 2 Dedos: Zoom</div>

    <script>
        const canvas = document.getElementById('glcanvas');
        const errorLog = document.getElementById('error-log');
        
        const gl = canvas.getContext('webgl2', { alpha: false });

        if (!gl) {
            errorLog.style.display = 'block';
            errorLog.innerText = 'ERRO: WebGL 2 não suportado.';
        }

        function showError(msg) {
            errorLog.style.display = 'block';
            errorLog.innerText = 'ERRO SHADER:\n' + msg;
        }

        const vsSource = `#version 300 es
            in vec4 position;
            void main() {
                gl_Position = position;
            }
        `;

        const fsSource = `#version 300 es
            precision highp float;
            
            uniform vec2 resolution;
            uniform float time;
            uniform float zoom;
            uniform vec2 rotation; // x = yaw (horizontal), y = pitch (vertical)
            
            out vec4 fragColor;

            // Função auxiliar para rotação 2D
            mat2 rot(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }

            void main() {
                vec2 r = resolution;
                float t = time;
                vec4 o = vec4(0.0);
                vec2 FC = gl_FragCoord.xy;

                float i=0.0, d=0.0, s=0.0, n=0.0, l=0.0, m=1.0; 
                
                // Matriz de rotação original do efeito (swirl do túnel)
                mat2 R_orig = mat2(cos(sin(t*0.5)*0.785 + vec4(0.0,33.0,11.0,0.0)));

                for(i=0.0; i < 64.0; i++){ 
                    
                    // Inicializa vetor K com Zoom
                    vec3 p, k = vec3( ((FC.xy*2.0 - r.xy)/r.y) * zoom, d - 10.0);
                    
                    // --- APLICAÇÃO DA ROTAÇÃO DO UTILIZADOR ---
                    // Rodar YZ (Pitch - olhar cima/baixo)
                    k.yz *= rot(rotation.y);
                    // Rodar XZ (Yaw - olhar esq/dir)
                    k.xz *= rot(rotation.x);
                    // ------------------------------------------

                    l = length(k.xy - vec2(0.2 + sin(t)/4.0, 0.3 + sin(t+t)/6.0));
                    k.xy *= d;
                    
                    // Aplica a rotação original do efeito
                    k.xz *= R_orig;
                    
                    // Lógica IF segura para mobile
                    if (k.y < -6.3) {
                        k.y = -k.y - 9.0;
                        m = 0.5;
                    }
                    
                    for(p = k*0.5, n = 0.01; n < 1.0; n += n) {
                        p.y += 0.9 + abs(dot(sin(p.x + 2.0*t + p/n), 0.2 + p - p)) * n;
                    }
                    
                    float term1 = sin(length(ceil(k*8.0).x + k));
                    float term2 = mix(sin(length(p) - 0.2), l, 0.3 - l);
                    float mixTerm = mix(term1, term2, smoothstep(5.5, 6.0, p.y));
                    
                    d += s = 0.012 + 0.08 * abs(max(mixTerm, length(k) - 5.0) - i/150.0);
                    
                    o += max(sin(vec4(1.0,2.0,3.0,1.0) + i*0.5) * 1.5/s + vec4(1.0,2.0,3.0,1.0) * 0.04/l, -length(k*k));
                }
                
                o = tanh(o*o/800000.0) * m;
                fragColor = vec4(o.rgb, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                showError(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        const vShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        
        if (vShader && fShader) {
            gl.attachShader(program, vShader);
            gl.attachShader(program, fShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                showError(gl.getProgramInfoLog(program));
            }
        }

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        gl.useProgram(program);

        const uTime = gl.getUniformLocation(program, 'time');
        const uRes = gl.getUniformLocation(program, 'resolution');
        const uZoom = gl.getUniformLocation(program, 'zoom');
        const uRot = gl.getUniformLocation(program, 'rotation');

        // --- Variáveis de Estado ---
        let zoomLevel = 1.0;
        let targetZoom = 1.0;
        
        let rotX = 0.0; // Yaw
        let rotY = 0.0; // Pitch
        let targetRotX = 0.0;
        let targetRotY = 0.0;

        // --- Variáveis de Interação ---
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let initialPinchDistance = null;
        let initialZoomAtPinch = null;

        // --- Mouse Events (Desktop) ---
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => isDragging = false);

        canvas.addEventListener('mousemove', e => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                targetRotX -= deltaX * 0.005;
                targetRotY -= deltaY * 0.005; // Invertido para sensação "natural"
                
                // Limite vertical para não virar de cabeça para baixo
                targetRotY = Math.max(-1.5, Math.min(1.5, targetRotY));

                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            targetZoom += e.deltaY * 0.005;
            targetZoom = Math.max(0.2, Math.min(targetZoom, 8.0));
        }, { passive: false });

        // --- Touch Events (Mobile) ---
        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                // Modo Rotação
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Modo Zoom (Pinch)
                isDragging = false; // Parar rotação se fizer pinch
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.hypot(dx, dy);
                initialZoomAtPinch = targetZoom;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // Evita scroll da página

            if (e.touches.length === 1 && isDragging) {
                // Rotação
                const deltaX = e.touches[0].clientX - lastX;
                const deltaY = e.touches[0].clientY - lastY;
                
                targetRotX -= deltaX * 0.008; // Sensibilidade mobile
                targetRotY -= deltaY * 0.008;
                targetRotY = Math.max(-1.5, Math.min(1.5, targetRotY));

                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } 
            else if (e.touches.length === 2 && initialPinchDistance) {
                // Zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.hypot(dx, dy);
                
                const ratio = initialPinchDistance / currentDistance;
                targetZoom = initialZoomAtPinch * ratio;
                targetZoom = Math.max(0.2, Math.min(targetZoom, 8.0));
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = null;
        });

        function resize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                gl.viewport(0, 0, width, height);
            }
        }

        function render(now) {
            resize();

            // Interpolação (Lerp) para movimento suave
            zoomLevel += (targetZoom - zoomLevel) * 0.1;
            rotX += (targetRotX - rotX) * 0.1;
            rotY += (targetRotY - rotY) * 0.1;

            gl.uniform1f(uTime, now * 0.001);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uZoom, zoomLevel);
            gl.uniform2f(uRot, rotX, rotY);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>


